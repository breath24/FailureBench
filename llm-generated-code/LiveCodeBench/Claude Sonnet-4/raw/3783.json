{
  "task_id": "3783",
  "task_description": "Given two integers, n and k, an alternating permutation is a permutation of the first n positive integers such that no two adjacent elements are both odd or both even.\nReturn the k-th alternating permutation sorted in lexicographical order. If there are fewer than k valid alternating permutations, return an empty list.\n \nExample 1:\n\nInput: n = 4, k = 6\nOutput: [3,4,1,2]\nExplanation:\nThe lexicographically-sorted alternating permutations of [1, 2, 3, 4] are:\n\n[1, 2, 3, 4]\n[1, 4, 3, 2]\n[2, 1, 4, 3]\n[2, 3, 4, 1]\n[3, 2, 1, 4]\n[3, 4, 1, 2] ← 6th permutation\n[4, 1, 2, 3]\n[4, 3, 2, 1]\n\nSince k = 6, we return [3, 4, 1, 2].\n\nExample 2:\n\nInput: n = 3, k = 2\nOutput: [3,2,1]\nExplanation:\nThe lexicographically-sorted alternating permutations of [1, 2, 3] are:\n\n[1, 2, 3]\n[3, 2, 1] ← 2nd permutation\n\nSince k = 2, we return [3, 2, 1].\n\nExample 3:\n\nInput: n = 2, k = 3\nOutput: []\nExplanation:\nThe lexicographically-sorted alternating permutations of [1, 2] are:\n\n[1, 2]\n[2, 1]\n\nThere are only 2 alternating permutations, but k = 3, which is out of range. Thus, we return an empty list [].\n\n \nConstraints:\n\n1 <= n <= 100\n1 <= k <= 10^15",
  "llm_response": "def permute(n, k):\n    def factorial(x):\n        if x <= 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n    \n    def count_alternating(remaining_odds, remaining_evens, last_was_odd):\n        if remaining_odds == 0 and remaining_evens == 0:\n            return 1\n        if remaining_odds == 0:\n            return factorial(remaining_evens) if not last_was_odd else 0\n        if remaining_evens == 0:\n            return factorial(remaining_odds) if last_was_odd else 0\n        \n        total = 0\n        if not last_was_odd:\n            total += factorial(remaining_odds) * factorial(remaining_evens)\n        else:\n            total += factorial(remaining_evens) * factorial(remaining_odds)\n        return total\n    \n    odds = [(i * 2 - 1) for i in range(1, (n + 1) // 2 + 1)]\n    evens = [(i * 2) for i in range(1, n // 2 + 1)]\n    \n    total_alternating = 0\n    for first in range(1, n + 1):\n        remaining_odds = odds[:]\n        remaining_evens = evens[:]\n        \n        if first % 2 == 1:\n            remaining_odds.remove(first)\n            last_was_odd = True\n        else:\n            remaining_evens.remove(first)\n            last_was_odd = False\n        \n        count = count_alternating(len(remaining_odds), len(remaining_evens), last_was_odd)\n        total_alternating += count\n    \n    if k > total_alternating:\n        return []\n    \n    result = []\n    remaining_odds = odds[:]\n    remaining_evens = evens[:]\n    current_k = k\n    \n    for first in range(1, n + 1):\n        temp_odds = remaining_odds[:]\n        temp_evens = remaining_evens[:]\n        \n        if first % 2 == 1:\n            if first not in temp_odds:\n                continue\n            temp_odds.remove(first)\n            last_was_odd = True\n        else:\n            if first not in temp_evens:\n                continue\n            temp_evens.remove(first)\n            last_was_odd = False\n        \n        count = count_alternating(len(temp_odds), len(temp_evens), last_was_odd)\n        \n        if current_k <= count:\n            result.append(first)\n            if first % 2 == 1:\n                remaining_odds.remove(first)\n            else:\n                remaining_evens.remove(first)\n            current_k -= 1\n            break\n        else:\n            current_k -= count\n    \n    while len(result) < n:\n        found = False\n        last_was_odd = result[-1] % 2 == 1\n        \n        candidates = remaining_evens if last_was_odd else remaining_odds\n        candidates.sort()\n        \n        for candidate in candidates:\n            temp_odds = remaining_odds[:]\n            temp_evens = remaining_evens[:]\n            \n            if candidate % 2 == 1:\n                temp_odds.remove(candidate)\n                next_last_was_odd = True\n            else:\n                temp_evens.remove(candidate)\n                next_last_was_odd = False\n            \n            count = count_alternating(len(temp_odds), len(temp_evens), next_last_was_odd)\n            \n            if current_k <= count:\n                result.append(candidate)\n                if candidate % 2 == 1:\n                    remaining_odds.remove(candidate)\n                else:\n                    remaining_evens.remove(candidate)\n                found = True\n                break\n            else:\n                current_k -= count\n        \n        if not found:\n            break\n    \n    return result",
  "model": "claude-sonnet-4"
}