{
  "task_id": "arc196_b",
  "task_description": "There is a grid of H rows and W columns.\nThe rows are numbered 0,1,\\ldots,H-1 from top to bottom, and the columns are numbered 0,1,\\ldots,W-1 from left to right.\nLet (i,j) denote the cell at row i and column j.\nYou are given H strings S_0, S_1, \\ldots, S_{H-1}, each of which is of length W and consists of A and B.\nIn each cell, one of the following two types of tiles is placed.\nLet S_{ij} denote the (j+1)-th character (0 \\le j \\le W-1) of the string S_i. The type of tile placed in cell (i,j) is S_{ij}.\n\n- Type A: A single line segment is drawn on the tile’s surface, connecting the midpoints of two adjacent edges.\n\n\n\n- Type B: A single line segment is drawn on the tile’s surface, connecting the midpoints of two opposite edges.\n\n\nThese tiles can be freely rotated. When focusing only on the pattern formed by the line segments, there are four ways to rotate a Type-A tile and two ways to rotate a Type-B tile. Therefore, if we distinguish placements only by the pattern of line segments, the number of ways to place the tiles is 4^a \\times 2^b, where a is the number of Type-A tiles and b is the number of Type-B tiles.\nAmong these ways, print the number, modulo 998244353, of ways such that the line segments on the tiles have no dead ends when viewing the grid as a torus.\nHere, \"the line segments on the tiles have no dead ends when viewing the grid as a torus\" if and only if the following two conditions are satisfied for every cell (i,j):\n\n- Both of the following exist, or neither of the following exists:\n- the line segment drawn in the cell (i,j), whose endpoint is the midpoint of the right edge of the cell (i,j)\n- the line segment drawn in the cell (i,(j+1)\\bmod W), whose endpoint is the midpoint of the left edge of the cell (i,(j+1)\\bmod W)\n\n\n- Both of the following exist, or neither of the following exists:\n- the line segment drawn in the cell (i,j), whose endpoint is the midpoint of the bottom edge of the cell (i,j)\n- the line segment drawn in the cell ((i+1)\\bmod H,j), whose endpoint is the midpoint of the top edge of the cell ((i+1)\\bmod H,j)\n\n\n\nFor example, the following placement satisfies the condition:\n\nThe following placement does not satisfy the condition. Specifically, while there is no line segment whose endpoint is the midpoint of the right edge of the tile in cell (0,2), there is a line segment whose endpoint is the midpoint of the left edge of the tile in cell (0,0), so the condition is not satisfied.\n\nYou are given T test cases; solve each of them.\n\nInput\n\nThe input is given from Standard Input in the following format:\nT\ncase_1\ncase_2\n\\vdots\ncase_T\n\nEach case is given in the following format:\nH W\nS_0\nS_1\n\\vdots\nS_{H-1}\n\nOutput\n\nFor each test case, print the number, modulo 998244353, of placements that satisfies the condition, in separate lines.\n\nConstraints\n\n\n- 1 \\le T \\le 10^5\n- 2 \\le H,W\n- HW\\leq 10^6\n- S_i\\,(0\\le i\\le H-1) are length-W strings consisting of A and B.\n- The sum of H W over all test cases is at most 10^6.\n- T, H, and W are integers.\n\nSample Input 1\n\n3\n3 3\nAAB\nAAB\nBBB\n3 3\nBBA\nABA\nAAB\n3 4\nBAAB\nBABA\nBBAA\n\nSample Output 1\n\n2\n0\n2\n\nOne valid placement for the first test case is shown in the following image:",
  "llm_response": "import sys\nMOD = 998244353\n\ndef candidate_func(input_str):\n    lines = input_str.split('\\n')\n    ptr = 0\n    T = int(lines[ptr])\n    ptr += 1\n    results = []\n    for _ in range(T):\n        if ptr >= len(lines):\n            break\n        H, W = map(int, lines[ptr].split())\n        ptr += 1\n        grid = []\n        for _ in range(H):\n            if ptr >= len(lines):\n                break\n            grid.append(lines[ptr].strip())\n            ptr += 1\n        a = 0\n        b = 0\n        for row in grid:\n            a += row.count('A')\n            b += row.count('B')\n        if H % 2 != 0 or W % 2 != 0:\n            results.append(0)\n            continue\n        valid = True\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == 'A' and grid[(i+1)%H][j] == 'A':\n                    pass\n                elif grid[i][j] == 'B' and grid[(i+1)%H][j] == 'B':\n                    pass\n                else:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            results.append(pow(2, a // 2 + b, MOD))\n            continue\n        valid = True\n        for j in range(W):\n            for i in range(H):\n                if grid[i][j] == 'A' and grid[i][(j+1)%W] == 'A':\n                    pass\n                elif grid[i][j] == 'B' and grid[i][(j+1)%W] == 'B':\n                    pass\n                else:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            results.append(pow(2, a // 2 + b, MOD))\n            continue\n        if H % 2 == 0 and W % 2 == 0:\n            results.append(pow(2, a + b, MOD))\n        else:\n            results.append(0)\n    return '\\n'.join(map(str, results))",
  "model": "deepseek-chat-v3-0324"
}