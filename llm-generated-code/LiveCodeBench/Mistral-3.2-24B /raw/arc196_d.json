{
  "task_id": "arc196_d",
  "task_description": "There are N towns, numbered 1,2,\\ldots,N, arranged in a line in this order.\nThere are N-1 roads connecting adjacent towns: road j\\,(1 \\leq j \\leq N-1) connects towns j and j+1. For each road j, you can set a strength w_j (an integer that may be negative).\nWhen a person travels along a road, their stamina changes. Specifically, if a person with stamina x travels along road j, their stamina becomes x + w_j.\nThere are M people who will now move between these towns.\nPerson i\\,(1 \\le i \\le M) starts with stamina 0 at town S_i and travels to town T_i via the shortest path.\r\nIt is guaranteed that |S_i - T_i| > 1. Also, (S_i, T_i) \\neq (S_j, T_j) if i \\neq j.\nPerson iâ€™s requirement is as follows:\n\nWhen departing Town S_i and when arriving at Town T_i, their stamina should be exactly 0. At every other town, their stamina should always be a positive integer.\n\nAssume that there are no changes to stamina other than those due to traveling along roads as described above.\nProcess Q queries. For the k-th query (1 \\le k \\le Q), if it is possible to set the strengths of the roads so that the requirements of all people L_k, L_k + 1, \\ldots, R_k are satisfied, print Yes; otherwise, print No.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN M Q\r\nS_1 T_1\r\nS_2 T_2\r\n\\vdots\r\nS_M T_M\r\nL_1 R_1\r\nL_2 R_2\r\n\\vdots\r\nL_Q R_Q\n\nOutput\n\nPrint Q lines.\nThe k-th line should contain Yes if there is a way to set the strengths of the roads so that the requirements of all people L_k, L_k + 1, \\ldots, R_k are satisfied, and No otherwise.\n\nConstraints\n\n\n- 3 \\le N \\le 4 \\times 10^5\n- 1 \\le M \\le 2 \\times 10^5\n- 1 \\le Q \\le 2 \\times 10^5\n- 1 \\le S_i, T_i \\le N\n- |S_i - T_i| > 1\n- (S_i, T_i) \\neq (S_j, T_j)\\,(i \\neq j)\n- 1 \\le L_k \\le R_k \\le M\n- All input values are integers.\n\nSample Input 1\n\n5 4 2\r\n4 2\r\n1 3\r\n3 5\r\n2 4\r\n1 3\r\n2 4\n\nSample Output 1\n\nYes\r\nNo\r\n\nFor the first query, consider setting the strengths of roads 1, 2, 3, 4 to 1, -1, 1, -1, respectively.\n\n- Person 1 starts at town 4 with stamina 0, visits town 3 with stamina 1, and arrives at town 2 with stamina 0.\n- Person 2 starts at town 1 with stamina 0, visits town 2 with stamina 1, and arrives at town 3 with stamina 0.\n- Person 3 starts at town 3 with stamina 0, visits town 4 with stamina 1, and arrives at town 5 with stamina 0.\n\nThus, this configuration satisfies the requirements of persons 1,2,3, so print Yes on the first line.\nFor the second query, it is impossible to satisfy the requirements of persons 2,3,4 simultaneously, so print No.\n\nSample Input 2\n\n7 6 3\r\n1 5\r\n2 4\r\n4 6\r\n7 1\r\n5 3\r\n1 6\r\n1 6\r\n4 4\r\n2 5\n\nSample Output 2\n\nNo\r\nYes\r\nYes",
  "llm_response": "def candidate_func(s):\n    import sys\n    from collections import defaultdict\n\n    lines = s.split('\\n')\n    idx = 0\n    N, M, Q = map(int, lines[idx].split())\n    idx += 1\n\n    people = []\n    for _ in range(M):\n        S, T = map(int, lines[idx].split())\n        if S > T:\n            S, T = T, S\n        people.append((S, T))\n        idx += 1\n\n    queries = []\n    for _ in range(Q):\n        L, R = map(int, lines[idx].split())\n        queries.append((L, R))\n        idx += 1\n\n    # Precompute the shortest paths\n    adj = defaultdict(list)\n    for i in range(1, N):\n        adj[i].append(i + 1)\n        adj[i + 1].append(i)\n\n    # For each person, find the path and the required weights\n    path_info = []\n    for S, T in people:\n        path = []\n        current = S\n        while current != T:\n            path.append(current)\n            for neighbor in adj[current]:\n                if neighbor > current:\n                    current = neighbor\n                    break\n        path.append(T)\n        path_info.append((S, T, path))\n\n    # For each path, compute the required weights\n    required_weights = []\n    for S, T, path in path_info:\n        n = len(path)\n        if n == 2:\n            required_weights.append((S, T, [0, 0]))\n            continue\n        # The stamina must be 0 at S and T, and positive at all other towns\n        # The path is S -> ... -> T\n        # The weights must satisfy:\n        # w1 + w2 + ... + w_{n-1} = 0\n        # For all i, 1 <= i <= n-2, w1 + w2 + ... + w_i > 0\n        # This is equivalent to:\n        # w1 = a1, w2 = a2 - a1, ..., w_{n-1} = 0 - (a1 + ... + a_{n-2})\n        # where a1 > 0, a2 > a1, ..., a_{n-2} > a_{n-3}\n        # So the weights are determined by the sequence a1, a2 - a1, ..., 0 - (a1 + ... + a_{n-2})\n        # The key observation is that the weights must be such that the partial sums are strictly increasing\n        # and the total sum is 0.\n        # This is only possible if the path length is even, and the weights alternate between positive and negative.\n        # For example, for path length 4: w1 = a, w2 = -a, w3 = a, w4 = -a\n        # So the required weights are determined by the parity of the path length.\n        # If the path length is even, the weights can be set to alternate between a and -a.\n        # If the path length is odd, it's impossible because the sum cannot be 0 with all partial sums positive.\n        if (n - 1) % 2 == 1:\n            required_weights.append((S, T, None))\n        else:\n            required_weights.append((S, T, [1 if i % 2 == 0 else -1 for i in range(n - 1)]))\n\n    # For each query, check if all the required weights in the range are possible\n    res = []\n    for L, R in queries:\n        valid = True\n        for i in range(L - 1, R):\n            S, T, weights = required_weights[i]\n            if weights is None:\n                valid = False\n                break\n        if valid:\n            res.append(\"Yes\")\n        else:\n            res.append(\"No\")\n    return '\\n'.join(res)",
  "model": "mistral-3.2-24b"
}