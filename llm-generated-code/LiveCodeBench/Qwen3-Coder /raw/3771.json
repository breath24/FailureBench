{
  "task_id": "3771",
  "task_description": "Given a string s of length n and an integer k, determine whether it is possible to select k disjoint special substrings.\nA special substring is a substring where:\n\nAny character present inside the substring should not appear outside it in the string.\nThe substring is not the entire string s.\n\nNote that all k substrings must be disjoint, meaning they cannot overlap.\nReturn true if it is possible to select k such disjoint special substrings; otherwise, return false.\n \nExample 1:\n\nInput: s = \"abcdbaefab\", k = 2\nOutput: true\nExplanation:\n\nWe can select two disjoint special substrings: \"cd\" and \"ef\".\n\"cd\" contains the characters 'c' and 'd', which do not appear elsewhere in s.\n\"ef\" contains the characters 'e' and 'f', which do not appear elsewhere in s.\n\n\nExample 2:\n\nInput: s = \"cdefdc\", k = 3\nOutput: false\nExplanation:\nThere can be at most 2 disjoint special substrings: \"e\" and \"f\". Since k = 3, the output is false.\n\nExample 3:\n\nInput: s = \"abeabe\", k = 0\nOutput: true\n\n \nConstraints:\n\n2 <= n == s.length <= 5 * 10^4\n0 <= k <= 26\ns consists only of lowercase English letters.",
  "llm_response": "def maxSubstringLength(s, k):\n    if k == 0:\n        return True\n    \n    n = len(s)\n    char_count = [0] * 26\n    \n    for c in s:\n        char_count[ord(c) - ord('a')] += 1\n    \n    def is_special(start, end):\n        substring_chars = [0] * 26\n        for i in range(start, end + 1):\n            substring_chars[ord(s[i]) - ord('a')] += 1\n        \n        for i in range(26):\n            if substring_chars[i] > 0 and substring_chars[i] != char_count[i]:\n                return False\n        return True\n    \n    memo = {}\n    \n    def dp(index, remaining):\n        if remaining == 0:\n            return True\n        if index >= n:\n            return False\n        if (index, remaining) in memo:\n            return memo[(index, remaining)]\n        \n        result = dp(index + 1, remaining)\n        \n        if not result:\n            for end in range(index, n - 1):\n                if is_special(index, end):\n                    if dp(end + 1, remaining - 1):\n                        result = True\n                        break\n        \n        memo[(index, remaining)] = result\n        return result\n    \n    return dp(0, k)",
  "model": "qwen3-coder"
}