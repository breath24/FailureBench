{
  "task_id": "3714",
  "task_description": "You are given an integer array nums and a positive integer k. Return the sum of the maximum and minimum elements of all subsequences of nums with at most k elements.\nSince the answer may be very large, return it modulo 10^9 + 7.\n \nExample 1:\n\nInput: nums = [1,2,3], k = 2\nOutput: 24\nExplanation:\nThe subsequences of nums with at most 2 elements are:\n\n\n\nSubsequence \nMinimum\nMaximum\nSum\n\n\n[1]\n1\n1\n2\n\n\n[2]\n2\n2\n4\n\n\n[3]\n3\n3\n6\n\n\n[1, 2]\n1\n2\n3\n\n\n[1, 3]\n1\n3\n4\n\n\n[2, 3]\n2\n3\n5\n\n\nFinal Total\n \n \n24\n\n\n\nThe output would be 24.\n\nExample 2:\n\nInput: nums = [5,0,6], k = 1\nOutput: 22\nExplanation: \nFor subsequences with exactly 1 element, the minimum and maximum values are the element itself. Therefore, the total is 5 + 5 + 0 + 0 + 6 + 6 = 22.\n\nExample 3:\n\nInput: nums = [1,1,1], k = 2\nOutput: 12\nExplanation:\nThe subsequences [1, 1] and [1] each appear 3 times. For all of them, the minimum and maximum are both 1. Thus, the total is 12.\n\n \nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^9\n1 <= k <= min(70, nums.length)",
  "llm_response": "def minMaxSums(nums, k):\n    MOD = 10**9 + 7\n    n = len(nums)\n    nums.sort()\n    \n    # Precompute factorials and inverse factorials\n    max_k = k + 1\n    fact = [1] * max_k\n    for i in range(1, max_k):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    def mod_inverse(a, mod):\n        return pow(a, mod - 2, mod)\n    \n    inv_fact = [1] * max_k\n    inv_fact[max_k - 1] = mod_inverse(fact[max_k - 1], MOD)\n    for i in range(max_k - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD\n    \n    def comb(n, r):\n        if r > n or r < 0:\n            return 0\n        return (fact[n] * inv_fact[r] % MOD) * inv_fact[n - r] % MOD\n    \n    total = 0\n    \n    for i in range(n):\n        # Number of subsequences where nums[i] is the minimum\n        # We can choose any subset of elements to the right (indices > i)\n        # with size from 0 to k-1\n        right_count = n - i - 1\n        min_contribution = 0\n        for j in range(k):\n            min_contribution = (min_contribution + comb(right_count, j)) % MOD\n        total = (total + nums[i] * min_contribution) % MOD\n        \n        # Number of subsequences where nums[i] is the maximum\n        # We can choose any subset of elements to the left (indices < i)\n        # with size from 0 to k-1\n        left_count = i\n        max_contribution = 0\n        for j in range(k):\n            max_contribution = (max_contribution + comb(left_count, j)) % MOD\n        total = (total + nums[i] * max_contribution) % MOD\n    \n    return total",
  "model": "qwen3-coder"
}