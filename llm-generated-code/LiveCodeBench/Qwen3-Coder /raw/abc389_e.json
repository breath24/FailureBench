{
  "task_id": "abc389_e",
  "task_description": "There are N types of products, each having 10^{100} units in stock.\nYou can buy any non-negative number of units of each product. To buy k units of the i-th product, it costs k^2 P_i yen.\nIf your total purchase cost is at most M yen, what is the maximum number of units you can buy in total?\n\nInput\n\nThe input is given from Standard Input in the following format:\nN M\r\nP_1 \\ldots P_N\n\nOutput\n\nPrint the answer.\n\nConstraints\n\n\n- 1 \\leq N \\leq 2 \\times 10^{5}\n- 1 \\leq M \\leq 10^{18}\n- 1 \\leq P_i \\leq 2 \\times 10^{9}\n- All input values are integers.\n\nSample Input 1\n\n3 9\r\n4 1 9\n\nSample Output 1\n\n3\r\n\nIf you buy one unit of the 1st product and two units of the 2nd product, the total purchase cost is 1^2 \\times 4 + 2^2 \\times 1 = 8. It is impossible to buy four or more units in total with a total cost of at most 9 yen, so the answer is 3.\n\nSample Input 2\n\n10 1000\r\n2 15 6 5 12 1 7 9 17 2\n\nSample Output 2\n\n53",
  "llm_response": "import sys\nimport heapq\n\ndef candidate_func(input_str):\n    lines = input_str.strip().split('\\n')\n    N, M = map(int, lines[0].split())\n    P = list(map(int, lines[1].split()))\n    \n    def max_units_for_cost_limit(max_cost):\n        total_units = 0\n        for price in P:\n            if price > max_cost:\n                continue\n            max_k = int((max_cost // price) ** 0.5)\n            while max_k * max_k * price > max_cost:\n                max_k -= 1\n            while (max_k + 1) * (max_k + 1) * price <= max_cost:\n                max_k += 1\n            total_units += max_k\n        return total_units\n    \n    def min_cost_for_units(target_units):\n        if target_units == 0:\n            return 0\n        pq = [(0, 0, i) for i in range(N)]\n        heapq.heapify(pq)\n        total_cost = 0\n        units_bought = [0] * N\n        \n        for _ in range(target_units):\n            cost, k, idx = heapq.heappop(pq)\n            total_cost = cost\n            units_bought[idx] += 1\n            new_cost = total_cost + (2 * units_bought[idx] + 1) * P[idx]\n            heapq.heappush(pq, (new_cost, units_bought[idx], idx))\n        \n        return total_cost\n    \n    left, right = 0, 0\n    for price in P:\n        right += int((M // price) ** 0.5) + 1\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        cost = min_cost_for_units(mid)\n        if cost <= M:\n            left = mid\n        else:\n            right = mid - 1\n    \n    return str(left)",
  "model": "qwen3-coder"
}