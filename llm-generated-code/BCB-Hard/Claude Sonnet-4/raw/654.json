{
  "task_id": "BigCodeBench/654",
  "instruct_prompt": "Fit an exponential decay function to the indices in the array where the first column matches the target value.\nThe function should output with:\n    tuple: Containing the optimized parameters of the fitting function (popt) and the matplotlib Axes object.\nYou should write self-contained code starting with:\n```\nimport matplotlib.pyplot as plt\nimport scipy.optimize as optimize\nimport numpy as np\ndef task_func(array, target_value):\n```",
  "llm_response": "import matplotlib.pyplot as plt\nimport scipy.optimize as optimize\nimport numpy as np\ndef task_func(array, target_value):\n    \"\"\"\n    Fit an exponential decay function to the indices in the array where the first column matches the target value.\n    \n    Parameters:\n    array (numpy.ndarray): 2D array where first column contains values to match against target_value\n    target_value: Value to match in the first column\n    \n    Returns:\n    tuple: Containing the optimized parameters of the fitting function (popt) and the matplotlib Axes object.\n    \"\"\"\n    # Find indices where first column matches target value\n    matching_indices = np.where(array[:, 0] == target_value)[0]\n    \n    if len(matching_indices) == 0:\n        raise ValueError(f\"No matching values found for target_value: {target_value}\")\n    \n    # Define exponential decay function: y = a * exp(-b * x) + c\n    def exponential_decay(x, a, b, c):\n        return a * np.exp(-b * x) + c\n    \n    # Use the indices as x values and their positions as y values\n    x_data = matching_indices.astype(float)\n    y_data = np.arange(len(matching_indices), dtype=float)\n    \n    # If we have only one point, we can't fit an exponential\n    if len(x_data) < 3:\n        # For insufficient data points, return simple parameters\n        popt = np.array([1.0, 0.1, 0.0])\n    else:\n        # Initial guess for parameters [a, b, c]\n        initial_guess = [max(y_data), 0.1, min(y_data)]\n        \n        try:\n            # Fit the exponential decay function\n            popt, _ = optimize.curve_fit(exponential_decay, x_data, y_data, \n                                       p0=initial_guess, maxfev=5000)\n        except (RuntimeError, ValueError):\n            # If fitting fails, use initial guess\n            popt = np.array(initial_guess)\n    \n    # Create plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    \n    # Plot original data points\n    ax.scatter(x_data, y_data, color='red', label='Data points', s=50, alpha=0.7)\n    \n    # Plot fitted curve\n    if len(x_data) > 1:\n        x_smooth = np.linspace(min(x_data), max(x_data), 100)\n        y_fitted = exponential_decay(x_smooth, *popt)\n        ax.plot(x_smooth, y_fitted, 'b-', label=f'Fitted: y = {popt[0]:.3f} * exp(-{popt[1]:.3f} * x) + {popt[2]:.3f}')\n    \n    ax.set_xlabel('Array Indices')\n    ax.set_ylabel('Position in Matching Sequence')\n    ax.set_title(f'Exponential Decay Fit for Target Value: {target_value}')\n    ax.legend()\n    ax.grid(True, alpha=0.3)\n    \n    return popt, ax",
  "model": "claude-sonnet-4"
}