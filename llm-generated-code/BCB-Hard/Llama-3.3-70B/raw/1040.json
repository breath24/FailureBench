{
  "task_id": "BigCodeBench/1040",
  "instruct_prompt": "Run a non-blocking echo server that appends the server's current time to received data and sends it back to the client, while handling exceptional conditions for each socket.\nThe function should output with:\n    str: A status message indicating the server's operation and run duration.\nYou should write self-contained code starting with:\n```\nimport socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n```",
  "llm_response": "import socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n    \"\"\"\n    Run a non-blocking echo server that appends the server's current time to received data and sends it back to the client.\n\n    Args:\n    - server_address (str): The address of the server. Defaults to \"localhost\".\n    - server_port (int): The port of the server. Defaults to 12345.\n    - buffer_size (int): The size of the buffer. Defaults to 1024.\n    - run_duration (int): The duration the server will run in seconds. Defaults to 5.\n\n    Returns:\n    - str: A status message indicating the server's operation and run duration.\n    \"\"\"\n\n    # Create a socket object\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # Set the socket to non-blocking mode\n    server_socket.setblocking(False)\n\n    # Bind the socket to the server address and port\n    server_socket.bind((server_address, server_port))\n\n    # Listen for incoming connections\n    server_socket.listen(5)\n\n    # Create a list to store the sockets\n    sockets = [server_socket]\n\n    # Create a queue to store the data to be sent\n    send_queue = {}\n\n    # Record the start time\n    start_time = datetime.now()\n\n    while (datetime.now() - start_time).total_seconds() < run_duration:\n        # Use select to wait for incoming connections or data\n        readable, writable, errored = select.select(sockets, [], [], 1)\n\n        for sock in readable:\n            # If the socket is the server socket, it means a new connection is incoming\n            if sock == server_socket:\n                # Accept the new connection\n                client_socket, client_address = server_socket.accept()\n                # Set the client socket to non-blocking mode\n                client_socket.setblocking(False)\n                # Add the client socket to the list of sockets\n                sockets.append(client_socket)\n                # Create a queue for the client socket\n                send_queue[client_socket] = queue.Queue()\n            else:\n                try:\n                    # Receive data from the client\n                    data = sock.recv(buffer_size)\n                    if data:\n                        # Append the server's current time to the received data\n                        data_with_time = data.decode() + \" - \" + str(datetime.now())\n                        # Put the data into the send queue\n                        send_queue[sock].put(data_with_time.encode())\n                    else:\n                        # If no data is received, it means the client has disconnected\n                        # Remove the client socket from the list of sockets\n                        sockets.remove(sock)\n                        # Close the client socket\n                        sock.close()\n                        # Remove the client socket from the send queue\n                        del send_queue[sock]\n                except ConnectionResetError:\n                    # Handle the exception when the client disconnects abruptly\n                    # Remove the client socket from the list of sockets\n                    sockets.remove(sock)\n                    # Close the client socket\n                    sock.close()\n                    # Remove the client socket from the send queue\n                    del send_queue[sock]\n\n        # Check if there are any sockets that are ready to send data\n        for sock in list(send_queue.keys()):\n            try:\n                # Get the data from the send queue\n                data = send_queue[sock].get_nowait()\n                # Send the data back to the client\n                sock.sendall(data)\n            except queue.Empty:\n                # If the send queue is empty, do nothing\n                pass\n            except ConnectionResetError:\n                # Handle the exception when the client disconnects abruptly\n                # Remove the client socket from the list of sockets\n                sockets.remove(sock)\n                # Close the client socket\n                sock.close()\n                # Remove the client socket from the send queue\n                del send_queue[sock]\n\n    # Close all the sockets\n    for sock in sockets:\n        sock.close()\n\n    # Return a status message\n    return f\"Server ran for {run_duration} seconds and handled all incoming connections.\"",
  "model": "llama-3.3-70b"
}