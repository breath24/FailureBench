{
  "task_id": "BigCodeBench/1040",
  "instruct_prompt": "Run a non-blocking echo server that appends the server's current time to received data and sends it back to the client, while handling exceptional conditions for each socket.\nThe function should output with:\n    str: A status message indicating the server's operation and run duration.\nYou should write self-contained code starting with:\n```\nimport socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n```",
  "llm_response": "import socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n    # Create server socket\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket.bind((server_address, server_port))\n    server_socket.listen(5)\n    server_socket.setblocking(0)  # Non-blocking\n    \n    # Data structures for select\n    inputs = [server_socket]\n    outputs = []\n    message_queues = {}\n    \n    # Track start time and run duration\n    start_time = datetime.now()\n    end_time = start_time + timedelta(seconds=run_duration)\n    \n    try:\n        while datetime.now() < end_time:\n            # Calculate timeout for select\n            time_remaining = end_time - datetime.now()\n            timeout = max(0, time_remaining.total_seconds())\n            \n            # Use select to handle multiple sockets\n            try:\n                readable, writable, exceptional = select.select(\n                    inputs, outputs, inputs, min(1.0, timeout)\n                )\n            except select.error:\n                break\n            \n            # Handle readable sockets\n            for sock in readable:\n                if sock is server_socket:\n                    # Handle new connection\n                    try:\n                        connection, client_address = sock.accept()\n                        connection.setblocking(0)\n                        inputs.append(connection)\n                        message_queues[connection] = queue.Queue()\n                    except socket.error:\n                        continue\n                else:\n                    # Handle data from existing connection\n                    try:\n                        data = sock.recv(buffer_size)\n                        if data:\n                            # Process data: append server time\n                            current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                            response = f\"{data.decode()} [Server time: {current_time}]\"\n                            message_queues[sock].put(response.encode())\n                            if sock not in outputs:\n                                outputs.append(sock)\n                        else:\n                            # Client closed connection\n                            if sock in outputs:\n                                outputs.remove(sock)\n                            inputs.remove(sock)\n                            sock.close()\n                            del message_queues[sock]\n                    except socket.error:\n                        # Handle socket exceptions\n                        if sock in outputs:\n                            outputs.remove(sock)\n                        inputs.remove(sock)\n                        sock.close()\n                        if sock in message_queues:\n                            del message_queues[sock]\n            \n            # Handle writable sockets\n            for sock in writable:\n                try:\n                    next_msg = message_queues[sock].get_nowait()\n                except queue.Empty:\n                    # No more messages for this socket\n                    outputs.remove(sock)\n                else:\n                    try:\n                        sock.send(next_msg)\n                    except socket.error:\n                        # Handle send error\n                        if sock in outputs:\n                            outputs.remove(sock)\n                        inputs.remove(sock)\n                        sock.close()\n                        del message_queues[sock]\n            \n            # Handle exceptional conditions\n            for sock in exceptional:\n                inputs.remove(sock)\n                if sock in outputs:\n                    outputs.remove(sock)\n                sock.close()\n                if sock in message_queues:\n                    del message_queues[sock]\n    \n    finally:\n        # Clean up\n        for sock in inputs:\n            sock.close()\n        inputs.clear()\n        outputs.clear()\n        message_queues.clear()\n    \n    # Calculate actual run duration\n    actual_duration = (datetime.now() - start_time).total_seconds()\n    return f\"Server ran for {actual_duration:.2f} seconds\"",
  "model": "qwen3-coder"
}