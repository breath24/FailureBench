{
  "task_id": "abc398_g",
  "task_description": "You are given a simple undirected graph with N vertices and M edges, with vertices labeled 1 to N and edges labeled 1 to M. The i-th edge connects vertices U_i and V_i. Initially, G does not contain an odd cycle.\nTakahashi and Aoki will play a game using this graph G. With Aoki going first, they take turns performing the following operation:\n\n- Choose a pair of integers (i,j) with 1 \\leq i < j \\leq N that satisfies both of the following conditions, then add an edge connecting vertices i and j to G.\n- G does not already have an edge connecting vertices i and j.\n- Adding an edge connecting vertices i and j does not create an odd cycle.\n\n\n\nA player who cannot perform this operation loses, and the other player wins.\nDetermine who wins when both players play optimally.\n\nWhat is an odd cycle?\nA sequence of vertices (v_0,v_1,\\ldots,v_k) of G is called an odd cycle if and only if all of the following conditions are satisfied:\n\n- k is odd.\n- v_0=v_k.\n- For every 1\\leq i \\leq k, there is an edge connecting v_{i-1} and v_{i}.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN M\nU_1 V_1\nU_2 V_2\n\\vdots\nU_M V_M\n\nOutput\n\nIf Aoki (the first player) wins, print Aoki; otherwise, if Takahashi (the second player) wins, print Takahashi.\n\nConstraints\n\n\n- 1 \\leq N \\leq 2\\times 10^5\n- 0 \\leq M \\leq 2\\times 10^5\n- 1 \\leq U_i < V_i \\leq N\n- The given graph does not contain an odd cycle.\n- The given graph does not contain multi-edges.\n- All input values are integers.\n\nSample Input 1\n\n4 3\n1 2\n2 3\n3 4\n\nSample Output 1\n\nAoki\n\nIf Aoki (the first player) adds the edge (1,4), Takahashi (the second player) cannot move. Thus, Aoki wins.\n\nSample Input 2\n\n4 2\n1 2\n3 4\n\nSample Output 2\n\nTakahashi\n\nNo matter how Aoki plays, Takahashi wins.\n\nSample Input 3\n\n9 5\n2 9\n2 3\n4 6\n5 7\n1 8\n\nSample Output 3\n\nAoki",
  "llm_response": "from sys import stdin\n\ndef candidate_func(input_str):\n    lines = input_str.splitlines()\n    n, m = map(int, lines[0].split())\n    edges = [list(map(int, line.split())) for line in lines[1:]]\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootx = find(x)\n        rooty = find(y)\n        if rootx != rooty:\n            if rank[rootx] > rank[rooty]:\n                parent[rooty] = rootx\n            else:\n                parent[rootx] = rooty\n                if rank[rootx] == rank[rooty]:\n                    rank[rooty] += 1\n\n    for u, v in edges:\n        union(u, v)\n\n    components = {}\n    for i in range(1, n + 1):\n        root = find(i)\n        if root not in components:\n            components[root] = []\n        components[root].append(i)\n\n    count = 0\n    for component in components.values():\n        size = len(component)\n        count += size * (size - 1) // 2 - (size - 1)\n\n    return 'Aoki' if count % 2 == 1 else 'Takahashi'\n\nresult = candidate_func(stdin.read())\nprint(result)",
  "model": "llama-3.3-70b"
}