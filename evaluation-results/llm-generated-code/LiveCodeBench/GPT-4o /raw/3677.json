{
  "task_id": "3677",
  "task_description": "You are given an m x n grid. A robot starts at the top-left corner of the grid (0, 0) and wants to reach the bottom-right corner (m - 1, n - 1). The robot can move either right or down at any point in time.\nThe grid contains a value coins[i][j] in each cell:\n\nIf coins[i][j] >= 0, the robot gains that many coins.\nIf coins[i][j] < 0, the robot encounters a robber, and the robber steals the absolute value of coins[i][j] coins.\n\nThe robot has a special ability to neutralize robbers in at most 2 cells on its path, preventing them from stealing coins in those cells.\nNote: The robot's total coins can be negative.\nReturn the maximum profit the robot can gain on the route.\n \nExample 1:\n\nInput: coins = [[0,1,-1],[1,-2,3],[2,-3,4]]\nOutput: 8\nExplanation:\nAn optimal path for maximum coins is:\n\nStart at (0, 0) with 0 coins (total coins = 0).\nMove to (0, 1), gaining 1 coin (total coins = 0 + 1 = 1).\nMove to (1, 1), where there's a robber stealing 2 coins. The robot uses one neutralization here, avoiding the robbery (total coins = 1).\nMove to (1, 2), gaining 3 coins (total coins = 1 + 3 = 4).\nMove to (2, 2), gaining 4 coins (total coins = 4 + 4 = 8).\n\n\nExample 2:\n\nInput: coins = [[10,10,10],[10,10,10]]\nOutput: 40\nExplanation:\nAn optimal path for maximum coins is:\n\nStart at (0, 0) with 10 coins (total coins = 10).\nMove to (0, 1), gaining 10 coins (total coins = 10 + 10 = 20).\nMove to (0, 2), gaining another 10 coins (total coins = 20 + 10 = 30).\nMove to (1, 2), gaining the final 10 coins (total coins = 30 + 10 = 40).\n\n\n \nConstraints:\n\nm == coins.length\nn == coins[i].length\n1 <= m, n <= 500\n-1000 <= coins[i][j] <= 1000",
  "llm_response": "import heapq\n\ndef maximumAmount(coins):\n    m, n = len(coins), len(coins[0])\n    dp = [[-float('inf')] * n for _ in range(m)]\n    dp[0][0] = coins[0][0]\n    heap = [(-coins[0][0], 0, 0, 0)]\n    \n    while heap:\n        neg_coins, x, y, neutralized = heapq.heappop(heap)\n        current_coins = -neg_coins\n        \n        if x == m - 1 and y == n - 1:\n            return current_coins\n        \n        for dx, dy in [(1, 0), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n:\n                new_coins = current_coins + coins[nx][ny]\n                if coins[nx][ny] < 0 and neutralized < 2:\n                    new_coins = current_coins\n                    if new_coins > dp[nx][ny]:\n                        dp[nx][ny] = new_coins\n                        heapq.heappush(heap, (-new_coins, nx, ny, neutralized + 1))\n                if new_coins > dp[nx][ny]:\n                    dp[nx][ny] = new_coins\n                    heapq.heappush(heap, (-new_coins, nx, ny, neutralized))",
  "model": "gpt-4o"
}