{
  "task_id": "3733",
  "task_description": "You are given a 2D integer matrix grid of size n x m, where each element is either 0, 1, or 2.\nA V-shaped diagonal segment is defined as:\n\nThe segment starts with 1.\nThe subsequent elements follow this infinite sequence: 2, 0, 2, 0, ....\nThe segment:\n\t\nStarts along a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).\nContinues the sequence in the same diagonal direction.\nMakes at most one clockwise 90-degree turn to another diagonal direction while maintaining the sequence.\n\n\n\n\nReturn the length of the longest V-shaped diagonal segment. If no valid segment exists, return 0.\n \nExample 1:\n\nInput: grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]\nOutput: 5\nExplanation:\n\nThe longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,2) → (1,3) → (2,4), takes a 90-degree clockwise turn at (2,4), and continues as (3,3) → (4,2).\n\nExample 2:\n\nInput: grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]\nOutput: 4\nExplanation:\n\nThe longest V-shaped diagonal segment has a length of 4 and follows these coordinates: (2,3) → (3,2), takes a 90-degree clockwise turn at (3,2), and continues as (2,1) → (1,0).\n\nExample 3:\n\nInput: grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]\nOutput: 5\nExplanation:\n\nThe longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,0) → (1,1) → (2,2) → (3,3) → (4,4).\n\nExample 4:\n\nInput: grid = [[1]]\nOutput: 1\nExplanation:\nThe longest V-shaped diagonal segment has a length of 1 and follows these coordinates: (0,0).\n\n \nConstraints:\n\nn == grid.length\nm == grid[i].length\n1 <= n, m <= 500\ngrid[i][j] is either 0, 1 or 2.",
  "llm_response": "def lenOfVDiagonal(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    n, m = len(grid), len(grid[0])\n    max_len = 0\n    \n    # Directions: (dr, dc) for the 4 diagonal directions\n    # Index 0: top-left to bottom-right\n    # Index 1: bottom-right to top-left\n    # Index 2: top-right to bottom-left\n    # Index 3: bottom-left to top-right\n    diagonals = [(-1, -1), (-1, 1), (1, -1), (1, 1)]\n    \n    # For each cell, try to start a V-segment\n    for i in range(n):\n        for j in range(m):\n            # Try starting a segment from (i,j) if it's a 1\n            if grid[i][j] != 1:\n                continue\n            \n            # Try each of the 4 diagonal directions as the initial direction\n            for d in range(4):\n                dr1, dc1 = diagonals[d]\n                \n                # First step: must be 2\n                ni, nj = i + dr1, j + dc1\n                if not (0 <= ni < n and 0 <= nj < m) or grid[ni][nj] != 2:\n                    continue\n                \n                # Now we have started the segment: 1 -> 2\n                segment = [(i, j), (ni, nj)]\n                current_len = 2\n                expected = 0  # Next expected is 0\n                \n                # Continue along the same diagonal direction\n                ci, cj = ni, nj\n                while True:\n                    ni2, nj2 = ci + dr1, cj + dc1\n                    if not (0 <= ni2 < n and 0 <= nj2 < m) or grid[ni2][nj2] != expected:\n                        break\n                    segment.append((ni2, nj2))\n                    current_len += 1\n                    expected = 2 if expected == 0 else 0\n                    ci, cj = ni2, nj2\n                \n                # Now try making a 90-degree clockwise turn\n                # Clockwise turn mapping:\n                # 0 (top-left to bottom-right) -> 3 (bottom-left to top-right)\n                # 1 (bottom-right to top-left) -> 2 (top-right to bottom-left)\n                # 2 (top-right to bottom-left) -> 0 (top-left to bottom-right)\n                # 3 (bottom-left to top-right) -> 1 (bottom-right to top-left)\n                turn_map = {0: 3, 1: 2, 2: 0, 3: 1}\n                new_d = turn_map[d]\n                dr2, dc2 = diagonals[new_d]\n                \n                # From the last point, try to continue in the new direction\n                # But we need to check that we don't go back to the previous cell\n                if len(segment) >= 2:\n                    last_i, last_j = segment[-1]\n                    prev_i, prev_j = segment[-2]\n                    \n                    # Try to continue in the new direction\n                    ni3, nj3 = last_i + dr2, last_j + dc2\n                    if (0 <= ni3 < n and 0 <= nj3 < m and \n                        (ni3, nj3) != (prev_i, prev_j) and \n                        grid[ni3][nj3] == expected):\n                        \n                        # Continue along the new direction\n                        ci2, cj2 = ni3, nj3\n                        segment2 = [(ni3, nj3)]\n                        current_len2 = 1\n                        expected2 = 2 if expected == 0 else 0\n                        \n                        while True:\n                            ni4, nj4 = ci2 + dr2, cj2 + dc2\n                            if not (0 <= ni4 < n and 0 <= nj4 < m) or grid[ni4][nj4] != expected2:\n                                break\n                            segment2.append((ni4, nj4))\n                            current_len2 += 1\n                            expected2 = 2 if expected2 == 0 else 0\n                            ci2, cj2 = ni4, nj4\n                        \n                        total_len = current_len + current_len2\n                        max_len = max(max_len, total_len)\n                \n                # Also consider the case where we don't make a turn\n                max_len = max(max_len, current_len)\n    \n    return max_len",
  "model": "qwen3-coder"
}