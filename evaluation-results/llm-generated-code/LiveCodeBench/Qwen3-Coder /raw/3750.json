{
  "task_id": "3750",
  "task_description": "You are given a circular array nums and an array queries.\nFor each query i, you have to find the following:\n\nThe minimum distance between the element at index queries[i] and any other index j in the circular array, where nums[j] == nums[queries[i]]. If no such index exists, the answer for that query should be -1.\n\nReturn an array answer of the same size as queries, where answer[i] represents the result for query i.\n \nExample 1:\n\nInput: nums = [1,3,1,4,1,3,2], queries = [0,3,5]\nOutput: [2,-1,3]\nExplanation:\n\nQuery 0: The element at queries[0] = 0 is nums[0] = 1. The nearest index with the same value is 2, and the distance between them is 2.\nQuery 1: The element at queries[1] = 3 is nums[3] = 4. No other index contains 4, so the result is -1.\nQuery 2: The element at queries[2] = 5 is nums[5] = 3. The nearest index with the same value is 1, and the distance between them is 3 (following the circular path: 5 -> 6 -> 0 -> 1).\n\n\nExample 2:\n\nInput: nums = [1,2,3,4], queries = [0,1,2,3]\nOutput: [-1,-1,-1,-1]\nExplanation:\nEach value in nums is unique, so no index shares the same value as the queried element. This results in -1 for all queries.\n\n \nConstraints:\n\n1 <= queries.length <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n0 <= queries[i] < nums.length",
  "llm_response": "def solveQueries(nums, queries):\n    from collections import defaultdict\n    import bisect\n    \n    n = len(nums)\n    value_to_indices = defaultdict(list)\n    \n    for i in range(n):\n        value_to_indices[nums[i]].append(i)\n    \n    answer = []\n    \n    for query_index in queries:\n        value = nums[query_index]\n        indices = value_to_indices[value]\n        \n        if len(indices) == 1:\n            answer.append(-1)\n            continue\n        \n        pos = bisect.bisect_left(indices, query_index)\n        min_dist = float('inf')\n        \n        candidates = []\n        if pos > 0:\n            candidates.append(indices[pos - 1])\n        if pos < len(indices):\n            candidates.append(indices[pos])\n        if pos > 0:\n            candidates.append(indices[pos - 1] - n)\n        if pos < len(indices):\n            candidates.append(indices[pos] + n)\n            \n        for idx in candidates:\n            if idx != query_index:\n                dist = min(abs(query_index - idx), n - abs(query_index - idx))\n                min_dist = min(min_dist, dist)\n                \n        answer.append(min_dist if min_dist != float('inf') else -1)\n        \n    return answer",
  "model": "qwen3-coder"
}