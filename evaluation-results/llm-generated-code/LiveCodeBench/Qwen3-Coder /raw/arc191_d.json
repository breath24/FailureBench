{
  "task_id": "arc191_d",
  "task_description": "You are given a simple connected undirected graph with N vertices and M edges, where the vertices are numbered 1 to N and the edges are numbered 1 to M. Edge i connects vertex u_i and vertex v_i in both directions.\nInitially, there is a piece A on vertex S and a piece B on vertex T. Here, S and T are given as input.\nYou may perform the following operation any number of times in any order:\n\n- Choose either piece A or piece B, and move it from its current vertex to an adjacent vertex via an edge. However, you cannot make a move that results in both pieces ending up on the same vertex.\n\nYour goal is to reach the state in which piece A is on vertex T and piece B is on vertex S.\nDetermine whether this is possible, and if it is, find the minimum number of operations required to achieve it.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN M S T\nu_1 v_1\nu_2 v_2\n\\vdots\nu_M v_M\n\nOutput\n\nIf it is impossible to achieve the goal, print -1.\nIf it is possible, print the minimum number of operations required.\n\nConstraints\n\n\n- 2 \\le N \\le 2\\times 10^5\n- \\displaystyle N-1 \\le M \\le \\min\\left(\\frac{N(N-1)}{2},\\,2\\times 10^5\\right)\n- 1 \\le u_i < v_i \\le N\n- The given graph is simple and connected.\n- 1 \\le S, T \\le N\n- S \\neq T\n- All input values are integers.\n\nSample Input 1\n\n4 4 3 4\n2 4\n1 4\n3 4\n2 3\n\nSample Output 1\n\n3\n\nFor example, the following sequence of operations completes the goal in three moves:\n\n- Move piece A to vertex 2.\n- Piece A is on vertex 2, piece B is on vertex 4.\n\n\n- Move piece B to vertex 3.\n- Piece A is on vertex 2, piece B is on vertex 3.\n\n\n- Move piece A to vertex 4.\n- Piece A is on vertex 4, piece B is on vertex 3.\n\n\n\nIt is impossible to complete the goal in fewer than three moves, so print 3.\n\nSample Input 2\n\n2 1 1 2\n1 2\n\nSample Output 2\n\n-1\n\nNo matter how you move the pieces, you cannot achieve the goal.\n\nSample Input 3\n\n5 6 3 5\n1 2\n2 3\n1 5\n2 4\n1 3\n2 5\n\nSample Output 3\n\n4",
  "llm_response": "from collections import deque, defaultdict\nimport sys\n\ndef candidate_func(input_data):\n    lines = input_data.strip().split('\\n')\n    N, M, S, T = map(int, lines[0].split())\n    \n    graph = defaultdict(list)\n    \n    for i in range(1, M+1):\n        u, v = map(int, lines[i].split())\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    if S == T:\n        return \"0\"\n    \n    queue = deque()\n    visited = set()\n    \n    queue.append((S, T, 0))\n    visited.add((S, T))\n    \n    while queue:\n        a_pos, b_pos, steps = queue.popleft()\n        \n        for next_a in graph[a_pos]:\n            if next_a == b_pos:\n                continue\n            for next_b in graph[b_pos]:\n                if next_b == a_pos:\n                    continue\n                if next_a == next_b:\n                    continue\n                if (next_a, next_b) in visited:\n                    continue\n                if next_a == T and next_b == S:\n                    return str(steps + 2)\n                visited.add((next_a, next_b))\n                queue.append((next_a, next_b, steps + 2))\n        \n        for next_a in graph[a_pos]:\n            if next_a == b_pos:\n                continue\n            if (next_a, b_pos) in visited:\n                continue\n            if next_a == T and b_pos == S:\n                return str(steps + 1)\n            visited.add((next_a, b_pos))\n            queue.append((next_a, b_pos, steps + 1))\n        \n        for next_b in graph[b_pos]:\n            if next_b == a_pos:\n                continue\n            if (a_pos, next_b) in visited:\n                continue\n            if a_pos == T and next_b == S:\n                return str(steps + 1)\n            visited.add((a_pos, next_b))\n            queue.append((a_pos, next_b, steps + 1))\n    \n    return \"-1\"",
  "model": "qwen3-coder"
}