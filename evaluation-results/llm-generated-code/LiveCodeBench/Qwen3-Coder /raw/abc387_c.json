{
  "task_id": "abc387_c",
  "task_description": "A positive integer not less than 10 whose top digit (the most significant digit) in decimal representation is strictly larger than every other digit in that number is called a Snake number.\nFor example, 31 and 201 are Snake numbers, but 35 and 202 are not.\nFind how many Snake numbers exist between L and R, inclusive.\n\nInput\n\nThe input is given from Standard Input in the following format:\nL R\n\nOutput\n\nPrint the answer.\n\nConstraints\n\n\n- 10 \\leq L \\leq R \\leq 10^{18}\n- All input values are integers.\n\nSample Input 1\n\n97 210\n\nSample Output 1\n\n6\n\nThe Snake numbers between 97 and 210, inclusive, are 97, 98, 100, 200, 201, and 210: there are six.\n\nSample Input 2\n\n1000 9999\n\nSample Output 2\n\n2025\n\nSample Input 3\n\n252509054433933519 760713016476190692\n\nSample Output 3\n\n221852052834757",
  "llm_response": "def candidate_func(input_str):\n    import sys\n    sys.setrecursionlimit(10000)\n    \n    def count_snake_numbers_up_to(n_str):\n        if not n_str:\n            return 0\n            \n        n_len = len(n_str)\n        if n_len == 1:\n            return 0\n            \n        memo = {}\n        \n        def dp(pos, is_limit, is_leading_zero, max_digit):\n            if pos == n_len:\n                return 1 if not is_leading_zero else 0\n                \n            if (pos, is_limit, is_leading_zero, max_digit) in memo:\n                return memo[(pos, is_limit, is_leading_zero, max_digit)]\n                \n            res = 0\n            upper = int(n_str[pos]) if is_limit else 9\n            \n            for digit in range(0, upper + 1):\n                if is_leading_zero and digit == 0:\n                    res += dp(pos + 1, is_limit and digit == upper, True, -1)\n                elif is_leading_zero and digit > 0:\n                    res += dp(pos + 1, is_limit and digit == upper, False, digit)\n                elif not is_leading_zero and digit < max_digit:\n                    res += dp(pos + 1, is_limit and digit == upper, False, max_digit)\n                    \n            memo[(pos, is_limit, is_leading_zero, max_digit)] = res\n            return res\n            \n        result = 0\n        first_upper = int(n_str[0])\n        \n        for first_digit in range(1, first_upper + 1):\n            if first_digit < 10:\n                is_limit = (first_digit == first_upper)\n                result += dp(1, is_limit, False, first_digit)\n                \n        for length in range(2, n_len):\n            for first_digit in range(1, 10):\n                res = 1\n                for i in range(1, length):\n                    res *= first_digit\n                result += res\n                \n        if n_len >= 2:\n            for first_digit in range(1, 10):\n                res = 1\n                valid = True\n                for i in range(1, n_len):\n                    if is_limit_for_position(i, first_digit, n_str):\n                        digit_limit = int(n_str[i])\n                        if digit_limit >= first_digit:\n                            res *= first_digit\n                        else:\n                            res = 0\n                            break\n                    else:\n                        res *= first_digit\n                if first_digit <= int(n_str[0]):\n                    result += res\n                    \n        return result\n        \n    def is_limit_for_position(pos, first_digit, n_str):\n        return pos < len(n_str) and first_digit <= int(n_str[0]) and all(int(n_str[i]) >= first_digit for i in range(1, pos)) if pos > 0 else True\n        \n    def count_snake_numbers_bruteforce(L, R):\n        count = 0\n        for num in range(L, R + 1):\n            s = str(num)\n            if len(s) >= 2:\n                first_digit = int(s[0])\n                valid = True\n                for i in range(1, len(s)):\n                    if int(s[i]) >= first_digit:\n                        valid = False\n                        break\n                if valid:\n                    count += 1\n        return count\n        \n    def count_snake(L_str):\n        if not L_str or len(L_str) < 2:\n            return 0\n            \n        L_len = len(L_str)\n        memo = {}\n        \n        def dfs(pos, is_limit, is_num, max_digit):\n            if pos == L_len:\n                return 1 if is_num else 0\n                \n            if (pos, is_limit, is_num, max_digit) in memo:\n                return memo[(pos, is_limit, is_num, max_digit)]\n                \n            res = 0\n            if not is_num:\n                res += dfs(pos + 1, False, False, -1)\n                \n            upper = int(L_str[pos]) if is_limit else 9\n            start = 0 if is_num else 1\n            \n            for digit in range(start, upper + 1):\n                if not is_num:\n                    res += dfs(pos + 1, is_limit and digit == upper, True, digit)\n                elif digit < max_digit:\n                    res += dfs(pos + 1, is_limit and digit == upper, True, max_digit)\n                    \n            memo[(pos, is_limit, is_num, max_digit)] = res\n            return res\n            \n        return dfs(0, True, False, -1)\n        \n    lines = input_str.strip().split()\n    L = int(lines[0])\n    R = int(lines[1])\n    \n    def count_snake_optimized(n):\n        if n < 10:\n            return 0\n            \n        s = str(n)\n        length = len(s)\n        result = 0\n        \n        for l in range(2, length):\n            for first in range(1, 10):\n                result += first ** (l - 1)\n                \n        if length >= 2:\n            first_digit = int(s[0])\n            for first in range(1, first_digit):\n                result += first ** (length - 1)\n                \n            if length > 1:\n                def count_valid(pos, is_limit, max_digit):\n                    if pos == length:\n                        return 1\n                        \n                    upper = int(s[pos]) if is_limit else 9\n                    res = 0\n                    for digit in range(0, min(upper + 1, max_digit)):\n                        res += count_valid(pos + 1, is_limit and digit == upper, max_digit)\n                    return res\n                    \n                result += count_valid(1, True, first_digit)\n                \n        return result\n        \n    def count_snake_final(n):\n        if n < 10:\n            return 0\n            \n        s = str(n)\n        length = len(s)\n        result = 0\n        \n        for l in range(2, length):\n            for first in range(1, 10):\n                result += first ** (l - 1)\n                \n        first_digit = int(s[0])\n        for first in range(1, first_digit):\n            result += first ** (length - 1)\n            \n        def dfs(pos, is_limit, is_num):\n            if pos == length:\n                return int(is_num)\n                \n            res = 0\n            if not is_num:\n                res += dfs(pos + 1, False, False)\n                \n            upper = int(s[pos]) if is_limit else 9\n            start = 1 - int(is_num)\n            \n            for digit in range(start, upper + 1):\n                if not is_num:\n                    res += dfs(pos + 1, is_limit and digit == upper, True)\n                elif pos == 1 and digit < first_digit:\n                    res += dfs(pos + 1, is_limit and digit == upper, True)\n                elif pos > 1 and digit < first_digit:\n                    res += dfs(pos + 1, is_limit and digit == upper, True)\n                    \n            return res\n            \n        if length >= 2:\n            result += dfs(1, True, False)\n            \n        return result\n        \n    def solve(L, R):\n        def count(n):\n            if n < 10:\n                return 0\n                \n            s = str(n)\n            l = len(s)\n            res = 0\n            \n            for i in range(2, l):\n                for d in range(1, 10):\n                    res += d ** (i - 1)\n                    \n            first = int(s[0])\n            for d in range(1, first):\n                res += d ** (l - 1)\n                \n            def dfs2(pos, is_limit):\n                if pos == l:\n                    return 1\n                    \n                up = int(s[pos]) if is_limit else 9\n                ret = 0\n                for digit in range(0, min(up + 1, first)):\n                    ret += dfs2(pos + 1, is_limit and digit == up)\n                return ret\n                \n            if l > 1:\n                res += dfs2(1, True)\n                \n            return res\n            \n        return count(R) - count(L - 1)\n        \n    def final_count(n):\n        if n < 10:\n            return 0\n            \n        s = str(n)\n        length = len(s)\n        result = 0\n        \n        for i in range(2, length):\n            for first in range(1, 10):\n                result += first ** (i - 1)\n                \n        first_digit = int(s[0])\n        for first in range(1, first_digit):\n            result += first ** (length - 1)\n            \n        memo = {}\n        def dp(pos, is_limit):\n            if pos == length:\n                return 1\n                \n            if (pos, is_limit) in memo:\n                return memo[(pos, is_limit)]\n                \n            upper = int(s[pos]) if is_limit else 9\n            res = 0\n            for digit in range(0, min(upper + 1, first_digit)):\n                res += dp(pos + 1, is_limit and digit == upper)\n                \n            memo[(pos, is_limit)] = res\n            return res\n            \n        if length >= 2:\n            result += dp(1, True)\n            \n        return result\n        \n    return str(final_count(R) - final_count(L - 1))",
  "model": "qwen3-coder"
}