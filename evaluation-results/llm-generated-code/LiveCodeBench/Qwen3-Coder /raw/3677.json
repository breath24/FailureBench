{
  "task_id": "3677",
  "task_description": "You are given an m x n grid. A robot starts at the top-left corner of the grid (0, 0) and wants to reach the bottom-right corner (m - 1, n - 1). The robot can move either right or down at any point in time.\nThe grid contains a value coins[i][j] in each cell:\n\nIf coins[i][j] >= 0, the robot gains that many coins.\nIf coins[i][j] < 0, the robot encounters a robber, and the robber steals the absolute value of coins[i][j] coins.\n\nThe robot has a special ability to neutralize robbers in at most 2 cells on its path, preventing them from stealing coins in those cells.\nNote: The robot's total coins can be negative.\nReturn the maximum profit the robot can gain on the route.\n \nExample 1:\n\nInput: coins = [[0,1,-1],[1,-2,3],[2,-3,4]]\nOutput: 8\nExplanation:\nAn optimal path for maximum coins is:\n\nStart at (0, 0) with 0 coins (total coins = 0).\nMove to (0, 1), gaining 1 coin (total coins = 0 + 1 = 1).\nMove to (1, 1), where there's a robber stealing 2 coins. The robot uses one neutralization here, avoiding the robbery (total coins = 1).\nMove to (1, 2), gaining 3 coins (total coins = 1 + 3 = 4).\nMove to (2, 2), gaining 4 coins (total coins = 4 + 4 = 8).\n\n\nExample 2:\n\nInput: coins = [[10,10,10],[10,10,10]]\nOutput: 40\nExplanation:\nAn optimal path for maximum coins is:\n\nStart at (0, 0) with 10 coins (total coins = 10).\nMove to (0, 1), gaining 10 coins (total coins = 10 + 10 = 20).\nMove to (0, 2), gaining another 10 coins (total coins = 20 + 10 = 30).\nMove to (1, 2), gaining the final 10 coins (total coins = 30 + 10 = 40).\n\n\n \nConstraints:\n\nm == coins.length\nn == coins[i].length\n1 <= m, n <= 500\n-1000 <= coins[i][j] <= 1000",
  "llm_response": "def maximumAmount(coins):\n    m, n = len(coins), len(coins[0])\n    # dp[i][j][k] = max profit at (i,j) with k neutralizations used\n    dp = [[[-float('inf')] * 3 for _ in range(n)] for _ in range(m)]\n    \n    # Base case\n    dp[0][0][0] = coins[0][0]\n    \n    # Fill first row\n    for j in range(1, n):\n        for k in range(3):\n            if dp[0][j-1][k] != -float('inf'):\n                if coins[0][j] < 0 and k < 2:\n                    dp[0][j][k+1] = max(dp[0][j][k+1], dp[0][j-1][k] + coins[0][j])\n                dp[0][j][k] = max(dp[0][j][k], dp[0][j-1][k] + (0 if coins[0][j] < 0 and k >= 2 else coins[0][j]))\n    \n    # Fill first column\n    for i in range(1, m):\n        for k in range(3):\n            if dp[i-1][0][k] != -float('inf'):\n                if coins[i][0] < 0 and k < 2:\n                    dp[i][0][k+1] = max(dp[i][0][k+1], dp[i-1][0][k] + coins[i][0])\n                dp[i][0][k] = max(dp[i][0][k], dp[i-1][0][k] + (0 if coins[i][0] < 0 and k >= 2 else coins[i][0]))\n    \n    # Fill rest of the dp table\n    for i in range(1, m):\n        for j in range(1, n):\n            for k in range(3):\n                # From top\n                if dp[i-1][j][k] != -float('inf'):\n                    if coins[i][j] < 0 and k < 2:\n                        dp[i][j][k+1] = max(dp[i][j][k+1], dp[i-1][j][k] + coins[i][j])\n                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k] + (0 if coins[i][j] < 0 and k >= 2 else coins[i][j]))\n                # From left\n                if dp[i][j-1][k] != -float('inf'):\n                    if coins[i][j] < 0 and k < 2:\n                        dp[i][j][k+1] = max(dp[i][j][k+1], dp[i][j-1][k] + coins[i][j])\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k] + (0 if coins[i][j] < 0 and k >= 2 else coins[i][j]))\n    \n    return max(max(dp[m-1][n-1]))",
  "model": "qwen3-coder"
}