{
  "task_id": "3722",
  "task_description": "You are given an integer array nums and two integers, k and m.\nReturn the maximum sum of k non-overlapping subarrays of nums, where each subarray has a length of at least m.\n \nExample 1:\n\nInput: nums = [1,2,-1,3,3,4], k = 2, m = 2\nOutput: 13\nExplanation:\nThe optimal choice is:\n\nSubarray nums[3..5] with sum 3 + 3 + 4 = 10 (length is 3 >= m).\nSubarray nums[0..1] with sum 1 + 2 = 3 (length is 2 >= m).\n\nThe total sum is 10 + 3 = 13.\n\nExample 2:\n\nInput: nums = [-10,3,-1,-2], k = 4, m = 1\nOutput: -10\nExplanation:\nThe optimal choice is choosing each element as a subarray. The output is (-10) + 3 + (-1) + (-2) = -10.\n\n \nConstraints:\n\n1 <= nums.length <= 2000\n-10^4 <= nums[i] <= 10^4\n1 <= k <= floor(nums.length / m)\n1 <= m <= 3",
  "llm_response": "def maxSum(nums, k, m):\n    n = len(nums)\n    memo = {}\n    \n    def dp(i, remaining):\n        if remaining == 0:\n            return 0\n        if i >= n:\n            return float('-inf')\n        \n        if (i, remaining) in memo:\n            return memo[(i, remaining)]\n        \n        result = dp(i + 1, remaining)\n        \n        current_sum = 0\n        for j in range(i, min(i + n - (remaining - 1) * m + 1, n)):\n            current_sum += nums[j]\n            if j - i + 1 >= m:\n                result = max(result, current_sum + dp(j + 1, remaining - 1))\n        \n        memo[(i, remaining)] = result\n        return result\n    \n    return dp(0, k)",
  "model": "claude-sonnet-4"
}