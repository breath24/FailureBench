{
  "task_id": "3720",
  "task_description": "You are given two integers, n and threshold, as well as a directed weighted graph of n nodes numbered from 0 to n - 1. The graph is represented by a 2D integer array edges, where edges[i] = [A_i, B_i, W_i] indicates that there is an edge going from node A_i to node B_i with weight W_i.\nYou have to remove some edges from this graph (possibly none), so that it satisfies the following conditions:\n\nNode 0 must be reachable from all other nodes.\nThe maximum edge weight in the resulting graph is minimized.\nEach node has at most threshold outgoing edges.\n\nReturn the minimum possible value of the maximum edge weight after removing the necessary edges. If it is impossible for all conditions to be satisfied, return -1.\n \nExample 1:\n\nInput: n = 5, edges = [[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold = 2\nOutput: 1\nExplanation:\n\nRemove the edge 2 -> 0. The maximum weight among the remaining edges is 1.\n\nExample 2:\n\nInput: n = 5, edges = [[0,1,1],[0,2,2],[0,3,1],[0,4,1],[1,2,1],[1,4,1]], threshold = 1\nOutput: -1\nExplanation: \nIt is impossible to reach node 0 from node 2.\n\nExample 3:\n\nInput: n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[3,4,2],[4,0,1]], threshold = 1\nOutput: 2\nExplanation: \n\nRemove the edges 1 -> 3 and 1 -> 4. The maximum weight among the remaining edges is 2.\n\nExample 4:\n\nInput: n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[4,0,1]], threshold = 1\nOutput: -1\n\n \nConstraints:\n\n2 <= n <= 10^5\n1 <= threshold <= n - 1\n1 <= edges.length <= min(10^5, n * (n - 1) / 2).\nedges[i].length == 3\n0 <= A_i, B_i < n\nA_i != B_i\n1 <= W_i <= 10^6\nThere may be multiple edges between a pair of nodes, but they must have unique weights.",
  "llm_response": "from collections import defaultdict, deque\n\ndef minMaxWeight(n, edges, threshold):\n    def canReachAll(maxWeight):\n        graph = defaultdict(list)\n        outDegree = defaultdict(int)\n        \n        validEdges = []\n        for a, b, w in edges:\n            if w <= maxWeight:\n                validEdges.append((a, b, w))\n        \n        validEdges.sort(key=lambda x: x[2])\n        \n        for a, b, w in validEdges:\n            if outDegree[a] < threshold:\n                graph[a].append(b)\n                outDegree[a] += 1\n        \n        visited = [False] * n\n        queue = deque([0])\n        visited[0] = True\n        reachable = 1\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    reachable += 1\n        \n        return reachable == n\n    \n    weights = sorted(set(w for _, _, w in edges))\n    left, right = 0, len(weights) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if canReachAll(weights[mid]):\n            result = weights[mid]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result",
  "model": "claude-sonnet-4"
}