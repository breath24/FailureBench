{
  "task_id": "arc192_d",
  "task_description": "For a positive rational number x, define f(x) as follows:\n\nExpress x as \\dfrac{P}{Q} using coprime positive integers P and Q. f(x) is defined as the value P\\times Q.\n\nYou are given a positive integer N and a sequence A=(A_1,A_2,\\dots,A_{N-1}) of positive integers of length N-1.\nWe call a sequence S=(S_1,S_2,\\dots,S_N) of positive integers of length N a good sequence if it satisfies all of the following conditions:\n\n- For every integer i with 1\\leq i\\leq N-1, it holds that f\\left(\\dfrac{S_i}{S_{i+1}}\\right)=A_i.\n- \\gcd(S_1,S_2,\\dots,S_N)=1.\n\nDefine the score of a sequence as the product of all its elements.\nIt can be proved that there are finitely many good sequences. Find the sum, modulo 998244353, of the scores of all good sequences.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN\nA_1 A_2 \\dots A_{N-1}\n\nOutput\n\nPrint the sum, modulo 998244353, of the scores of all good sequences.\n\nConstraints\n\n\n- 2\\leq N\\leq 1000\n- 1\\leq A_i\\leq 1000 (1\\leq i\\leq N-1)\n- All input values are integers.\n\nSample Input 1\n\n6\n1 9 2 2 9\n\nSample Output 1\n\n939634344\n\nFor example, both (2,2,18,9,18,2) and (18,18,2,1,2,18) are good sequences, and both have a score of 23328.\nThere are a total of 16 good sequences, and the sum of the scores of all of them is 939634344.\n\nSample Input 2\n\n2\n9\n\nSample Output 2\n\n18\n\nThere are 2 good sequences, both with a score of 9.\n\nSample Input 3\n\n25\n222 299 229 22 999 922 99 992 22 292 222 229 992 922 22 992 222 222 99 29 92 999 2 29\n\nSample Output 3\n\n192457116\n\nDo not forget to compute the sum modulo 998244353.",
  "llm_response": "import sys\nimport math\nfrom functools import lru_cache\n\nMOD = 998244353\n\ndef candidate_func(s):\n    lines = s.split('\\n')\n    N = int(lines[0])\n    A = list(map(int, lines[1].split()))\n\n    @lru_cache(maxsize=None)\n    def gcd(a, b):\n        return math.gcd(a, b)\n\n    @lru_cache(maxsize=None)\n    def solve(i, current_gcd, prev):\n        if i == N - 1:\n            if current_gcd == 1:\n                return 1\n            else:\n                return 0\n        total = 0\n        for p in range(1, A[i] + 1):\n            if A[i] % p != 0:\n                continue\n            q = A[i] // p\n            if gcd(p, q) != 1:\n                continue\n            new_gcd = gcd(current_gcd, p)\n            if new_gcd == 0:\n                continue\n            total += solve(i + 1, new_gcd, p * q)\n        return total\n\n    @lru_cache(maxsize=None)\n    def solve_with_score(i, current_gcd, prev, score):\n        if i == N - 1:\n            if current_gcd == 1:\n                return score\n            else:\n                return 0\n        total = 0\n        for p in range(1, A[i] + 1):\n            if A[i] % p != 0:\n                continue\n            q = A[i] // p\n            if gcd(p, q) != 1:\n                continue\n            new_gcd = gcd(current_gcd, p)\n            if new_gcd == 0:\n                continue\n            total += solve_with_score(i + 1, new_gcd, p * q, score * p)\n        return total\n\n    total_sequences = solve(0, 1, 1)\n    if total_sequences == 0:\n        return \"0\"\n\n    total_score = 0\n    for p in range(1, A[0] + 1):\n        if A[0] % p != 0:\n            continue\n        q = A[0] // p\n        if gcd(p, q) != 1:\n            continue\n        new_gcd = gcd(1, p)\n        if new_gcd == 0:\n            continue\n        total_score += solve_with_score(1, new_gcd, p * q, p)\n    total_score %= MOD\n    return str(total_score)",
  "model": "mistral-3.2-24b"
}