{
  "task_id": "arc192_e",
  "task_description": "You are given integers W,H,L,R,D,U.\nA town of Kyoto is on the two-dimensional plane.\nIn the town, there is exactly one block at each lattice point (x,y) that satisfies all of the following conditions. There are no blocks at any other points.\n\n- 0\\leq x\\leq W\n- 0\\leq y\\leq H\n- x<L or R<x or y<D or U<y\n\nSnuke traveled through the town as follows.\n\n- First, he chooses one block and stands there.\n- Then, he performs the following operation any number of times (possibly zero):\n- Move one unit in the positive direction of the x-axis or the positive direction of the y-axis. However, the point after moving must also have a block.\n\n\n\nPrint the number, modulo 998244353, of possible paths that Snuke could have taken.\n\nInput\n\nThe input is given from Standard Input in the following format:\nW H L R D U\n\nOutput\n\nPrint the answer.\n\nConstraints\n\n\n- 0\\leq L\\leq R\\leq W\\leq 10^6\n- 0\\leq D\\leq U\\leq H\\leq 10^6\n- There is at least one block.\n- All input values are integers.\n\nSample Input 1\n\n4 3 1 2 2 3\n\nSample Output 1\n\n192\r\n\nThe following are examples of possible paths. Here, a path is represented by listing the lattice points visited in order.\n\n- (3,0)\n- (0,0)\\rightarrow (1,0)\\rightarrow (2,0)\\rightarrow (2,1)\\rightarrow (3,1)\\rightarrow (3,2)\\rightarrow (4,2)\\rightarrow (4,3)\n- (0,1)\\rightarrow (0,2)\n\nThere are 192 possible paths.\n\nSample Input 2\n\n10 12 4 6 8 11\n\nSample Output 2\n\n4519189\n\nSample Input 3\n\n192 25 0 2 0 9\n\nSample Output 3\n\n675935675\r\n\nDo not forget to print the number of paths modulo 998244353.",
  "llm_response": "def candidate_func(input_str):\n    import sys\n    sys.setrecursionlimit(10**6)\n    \n    MOD = 998244353\n    \n    def modinv(a, p):\n        return pow(a, p - 2, p)\n    \n    def comb(n, k, p):\n        if n < k or k < 0:\n            return 0\n        return fact[n] * ifact[k] % p * ifact[n - k] % p\n    \n    W, H, L, R, D, U = map(int, input_str.split())\n    \n    fact = [1] * (W + H + 2)\n    ifact = [1] * (W + H + 2)\n    \n    for i in range(2, W + H + 2):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    ifact[W + H + 1] = modinv(fact[W + H + 1], MOD)\n    \n    for i in range(W + H, 0, -1):\n        ifact[i] = ifact[i + 1] * (i + 1) % MOD\n    \n    total_paths = comb(W + H, W, MOD)\n    \n    def count_invalid_paths(x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return 0\n        return comb(x2 + y2 - x1 - y1, x2 - x1, MOD)\n    \n    invalid_paths = 0\n    \n    for x in range(L, R + 1):\n        invalid_paths += count_invalid_paths(0, 0, x - 1, D - 1) * count_invalid_paths(x, U + 1, W, H) % MOD\n        invalid_paths %= MOD\n    \n    for y in range(D, U + 1):\n        invalid_paths += count_invalid_paths(0, 0, L - 1, y - 1) * count_invalid_paths(R + 1, y, W, H) % MOD\n        invalid_paths %= MOD\n    \n    result = (total_paths - invalid_paths + MOD) % MOD\n    \n    return str(result)",
  "model": "gpt-4o"
}