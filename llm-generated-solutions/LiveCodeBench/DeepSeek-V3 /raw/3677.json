{
  "task_id": "3677",
  "task_description": "You are given an m x n grid. A robot starts at the top-left corner of the grid (0, 0) and wants to reach the bottom-right corner (m - 1, n - 1). The robot can move either right or down at any point in time.\nThe grid contains a value coins[i][j] in each cell:\n\nIf coins[i][j] >= 0, the robot gains that many coins.\nIf coins[i][j] < 0, the robot encounters a robber, and the robber steals the absolute value of coins[i][j] coins.\n\nThe robot has a special ability to neutralize robbers in at most 2 cells on its path, preventing them from stealing coins in those cells.\nNote: The robot's total coins can be negative.\nReturn the maximum profit the robot can gain on the route.\n \nExample 1:\n\nInput: coins = [[0,1,-1],[1,-2,3],[2,-3,4]]\nOutput: 8\nExplanation:\nAn optimal path for maximum coins is:\n\nStart at (0, 0) with 0 coins (total coins = 0).\nMove to (0, 1), gaining 1 coin (total coins = 0 + 1 = 1).\nMove to (1, 1), where there's a robber stealing 2 coins. The robot uses one neutralization here, avoiding the robbery (total coins = 1).\nMove to (1, 2), gaining 3 coins (total coins = 1 + 3 = 4).\nMove to (2, 2), gaining 4 coins (total coins = 4 + 4 = 8).\n\n\nExample 2:\n\nInput: coins = [[10,10,10],[10,10,10]]\nOutput: 40\nExplanation:\nAn optimal path for maximum coins is:\n\nStart at (0, 0) with 10 coins (total coins = 10).\nMove to (0, 1), gaining 10 coins (total coins = 10 + 10 = 20).\nMove to (0, 2), gaining another 10 coins (total coins = 20 + 10 = 30).\nMove to (1, 2), gaining the final 10 coins (total coins = 30 + 10 = 40).\n\n\n \nConstraints:\n\nm == coins.length\nn == coins[i].length\n1 <= m, n <= 500\n-1000 <= coins[i][j] <= 1000",
  "llm_response": "import sys\n\ndef maximumAmount(coins):\n    m = len(coins)\n    n = len(coins[0])\n    dp = [[[-sys.maxsize] * 3 for _ in range(n)] for __ in range(m)]\n    dp[0][0][0] = coins[0][0]\n    if coins[0][0] < 0:\n        if 1 < 3:\n            dp[0][0][1] = 0\n    for i in range(m):\n        for j in range(n):\n            for k in range(3):\n                if i == 0 and j == 0:\n                    continue\n                current = -sys.maxsize\n                if i > 0:\n                    current = max(current, dp[i-1][j][k])\n                if j > 0:\n                    current = max(current, dp[i][j-1][k])\n                if current == -sys.maxsize:\n                    continue\n                val = coins[i][j]\n                if val < 0:\n                    if k < 2:\n                        current_val = current\n                        if current_val > dp[i][j][k+1]:\n                            dp[i][j][k+1] = current_val\n                    dp[i][j][k] = current + val\n                else:\n                    dp[i][j][k] = current + val\n    return max(dp[m-1][n-1])",
  "model": "deepseek-chat-v3-0324"
}