{
  "task_id": "abc395_e",
  "task_description": "You are given a directed graph with N vertices and M edges.\r\nThe i-th edge (1 \\leq i \\leq M) is a directed edge from vertex u _ i to vertex v _ i.\nInitially, you are at vertex 1. You want to repeat the following operations until you reach vertex N:\n\n- Perform one of the two operations below:\n- Move along a directed edge from your current vertex. This incurs a cost of 1. More precisely, if you are at vertex v, choose a vertex u such that there is a directed edge from v to u, and move to vertex u.\n- Reverse the direction of all edges. This incurs a cost of X. More precisely, if and only if there was a directed edge from v to u immediately before this operation, there is a directed edge from u to v immediately after this operation.\n\n\n\nIt is guaranteed that, for the given graph, you can reach vertex N from vertex 1 by repeating these operations.\nFind the minimum total cost required to reach vertex N.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN M X\r\nu _ 1 v _ 1\r\nu _ 2 v _ 2\r\n\\vdots\r\nu _ M v _ M\n\nOutput\n\nPrint the minimum total cost required to reach vertex N.\n\nConstraints\n\n\n- 2 \\leq N \\leq 2 \\times 10^5\n- 1 \\leq M \\leq 2 \\times 10^5\n- 1 \\leq X \\leq 10^9\n- 1 \\leq u _ i \\leq N \\ (1 \\leq i \\leq M)\n- 1 \\leq v _ i \\leq N \\ (1 \\leq i \\leq M)\n- For the given graph, it is guaranteed that you can reach vertex N from vertex 1 by the operations described.\n- All input values are integers.\n\nSample Input 1\n\n5 6 5\r\n1 2\r\n2 4\r\n3 1\r\n3 5\r\n4 3\r\n5 2\n\nSample Output 1\n\n4\r\n\nThe given graph looks like this:\n\nYou can reach vertex 5 with a total cost of 4 by doing the following:\n\n- Move to vertex 2 at a cost of 1.\n- Move to vertex 4 at a cost of 1.\n- Move to vertex 3 at a cost of 1.\n- Move to vertex 5 at a cost of 1.\n\nIt is impossible to reach vertex 5 with a total cost of 3 or less, so print 4.\n\nSample Input 2\n\n5 6 1\r\n1 2\r\n2 4\r\n3 1\r\n3 5\r\n4 3\r\n5 2\n\nSample Output 2\n\n3\r\n\nThe graph is the same as in Sample 1, but the cost to reverse edges is different.\nYou can reach vertex 5 with a total cost of 3 as follows:\n\n- Move to vertex 2 at a cost of 1.\n- Reverse all edges at a cost of 1.\n- Move to vertex 5 at a cost of 1.\n\nIt is impossible to reach vertex 5 with a total cost of 2 or less, so print 3.\n\nSample Input 3\n\n8 7 613566756\r\n2 1\r\n2 3\r\n4 3\r\n4 5\r\n6 5\r\n6 7\r\n8 7\n\nSample Output 3\n\n4294967299\r\n\nNote that the answer may exceed the 32-bit integer range.\n\nSample Input 4\n\n20 13 5\r\n1 3\r\n14 18\r\n18 17\r\n12 19\r\n3 5\r\n4 6\r\n13 9\r\n8 5\r\n14 2\r\n20 18\r\n8 14\r\n4 9\r\n14 8\n\nSample Output 4\n\n21",
  "llm_response": "import sys\nimport heapq\n\ndef candidate_func(input_str):\n    lines = input_str.split('\\n')\n    N, M, X = map(int, lines[0].split())\n    adj = [[] for _ in range(N + 1)]\n    rev_adj = [[] for _ in range(N + 1)]\n    for line in lines[1:M+1]:\n        u, v = map(int, line.split())\n        adj[u].append(v)\n        rev_adj[v].append(u)\n    INF = 1 << 60\n    dist = [[INF] * (N + 1) for _ in range(2)]\n    dist[0][1] = 0\n    heap = []\n    heapq.heappush(heap, (0, 1, 0))\n    while heap:\n        current_dist, u, flipped = heapq.heappop(heap)\n        if u == N:\n            return str(current_dist)\n        if current_dist > dist[flipped][u]:\n            continue\n        if flipped == 0:\n            for v in adj[u]:\n                if dist[0][v] > current_dist + 1:\n                    dist[0][v] = current_dist + 1\n                    heapq.heappush(heap, (dist[0][v], v, 0))\n            if dist[1][u] > current_dist + X:\n                dist[1][u] = current_dist + X\n                heapq.heappush(heap, (dist[1][u], u, 1))\n        else:\n            for v in rev_adj[u]:\n                if dist[1][v] > current_dist + 1:\n                    dist[1][v] = current_dist + 1\n                    heapq.heappush(heap, (dist[1][v], v, 1))\n            if dist[0][u] > current_dist + X:\n                dist[0][u] = current_dist + X\n                heapq.heappush(heap, (dist[0][u], u, 0))\n    return str(-1)",
  "model": "deepseek-chat-v3-0324"
}