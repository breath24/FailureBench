{
  "task_id": "abc388_f",
  "task_description": "There are N squares arranged in a row, labeled 1, 2, \\ldots, N from left to right.\nYou are given M pairs of integers (L_1, R_1), \\ldots, (L_M, R_M).\nA square j is defined to be bad if and only if there exists some i such that L_i \\leq j \\leq R_i.\nDetermine whether you can move from square 1 to square N by repeatedly performing the following action:\n\n- Let your current square be x. Choose an integer i that satisfies all of the following conditions, and move to square x + i.\n- A \\leq i \\leq B\n- x + i \\leq N\n- Square x + i is not bad.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN M A B\r\nL_1 R_1\r\nL_2 R_2\r\n\\vdots\r\nL_M R_M\n\nOutput\n\nIf it is possible to reach square N by repeating the action described in the problem statement, print Yes. Otherwise, print No.\n\nConstraints\n\n\n- 2 \\leq N \\leq 10^{12}\n- 0 \\leq M \\leq 2 \\times 10^4\n- 1 \\leq A \\leq B \\leq 20\n- 1 < L_i \\leq R_i < N \\ (1 \\leq i \\leq M)\n- R_i < L_{i+1} \\ (1 \\leq i \\leq M - 1)\n- All input values are integers.\n\nSample Input 1\n\n24 2 3 5\r\n7 8\r\n17 20\n\nSample Output 1\n\nYes\r\n\nYou can move to square N in this way: 1 \\to 6 \\to 9 \\to 12 \\to 16 \\to 21 \\to 24.\n\nSample Input 2\n\n30 1 5 8\r\n4 24\n\nSample Output 2\n\nNo\n\nSample Input 3\n\n100 4 10 11\r\n16 18\r\n39 42\r\n50 55\r\n93 99\n\nSample Output 3\n\nYes",
  "llm_response": "def candidate_func(input_str):\n    lines = input_str.strip().split('\\n')\n    N, M, A, B = map(int, lines[0].split())\n    \n    bad_ranges = []\n    for i in range(1, M + 1):\n        L, R = map(int, lines[i].split())\n        bad_ranges.append((L, R))\n    \n    def is_bad(pos):\n        for L, R in bad_ranges:\n            if L <= pos <= R:\n                return True\n        return False\n    \n    def can_reach(start, end):\n        if start >= end:\n            return start == end\n        \n        for step in range(A, B + 1):\n            next_pos = start + step\n            if next_pos > end:\n                break\n            if not is_bad(next_pos):\n                if can_reach(next_pos, end):\n                    return True\n        return False\n    \n    def solve():\n        if M == 0:\n            return True\n        \n        positions = [1]\n        for L, R in bad_ranges:\n            positions.extend([L - 1, L, R, R + 1])\n        positions.append(N)\n        \n        positions = sorted(set(pos for pos in positions if 1 <= pos <= N))\n        \n        reachable = [False] * len(positions)\n        pos_to_idx = {pos: i for i, pos in enumerate(positions)}\n        \n        if 1 in pos_to_idx:\n            reachable[pos_to_idx[1]] = True\n        \n        for i in range(len(positions)):\n            if not reachable[i]:\n                continue\n            \n            current_pos = positions[i]\n            \n            for j in range(i + 1, len(positions)):\n                target_pos = positions[j]\n                if target_pos - current_pos > B:\n                    break\n                \n                if target_pos - current_pos >= A and not is_bad(target_pos):\n                    can_reach_target = True\n                    \n                    for step in range(A, min(B + 1, target_pos - current_pos + 1)):\n                        intermediate = current_pos + step\n                        if intermediate < target_pos and is_bad(intermediate):\n                            can_reach_target = False\n                            break\n                    \n                    if can_reach_target:\n                        reachable[j] = True\n        \n        return N in pos_to_idx and reachable[pos_to_idx[N]]\n    \n    return \"Yes\" if solve() else \"No\"",
  "model": "claude-sonnet-4"
}