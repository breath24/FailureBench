{
  "task_id": "abc391_g",
  "task_description": "You are given a lowercase English string S of length N and an integer M. For each k=0,1,\\ldots,N, solve the following problem:\n\n- There are 26^M lowercase English strings of length M. Among these, find the number, modulo 998244353, of strings whose longest common subsequence with S has length exactly k.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN M\r\nS\n\nOutput\n\nLet \\mathrm{ans}_i be the answer for k=i. Print the answers in the following format:\n\\mathrm{ans}_0 \\mathrm{ans}_1 \\ldots \\mathrm{ans}_N\n\nConstraints\n\n\n- 1\\leq N\\leq 10\n- 1\\leq M\\leq 100\n- N and M are integers.\n- S is a lowercase English string of length N.\n\nSample Input 1\n\n2 2\r\nab\n\nSample Output 1\n\n576 99 1\r\n\nThe answers for k=0,1,2 are as follows:\n\n- For k=0: Among length 2 lowercase English strings, those with a longest common subsequence of length 0 with ab include strings such as cd, re, zz, totaling 576.\n- For k=1: Among length 2 lowercase English strings, those with a longest common subsequence of length 1 with ab include strings such as ac, wa, ba, totaling 99.\n- For k=2: Among length 2 lowercase English strings, there is 1 string (ab) whose longest common subsequence with ab has length 2.\n\nSample Input 2\n\n3 4\r\naaa\n\nSample Output 2\n\n390625 62500 3750 101\n\nSample Input 3\n\n7 50\r\natcoder\n\nSample Output 3\n\n309810541 226923474 392073062 146769908 221445233 435648037 862664208 238437587",
  "llm_response": "def candidate_func(input_str):\n    lines = input_str.strip().split('\\n')\n    N, M = map(int, lines[0].split())\n    S = lines[1]\n    \n    MOD = 998244353\n    \n    dp = {}\n    \n    def solve(pos_s, pos_t, lcs_len):\n        if pos_t == M:\n            return 1 if lcs_len == target_k else 0\n        \n        if (pos_s, pos_t, lcs_len) in dp:\n            return dp[(pos_s, pos_t, lcs_len)]\n        \n        result = 0\n        \n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            new_pos_s = pos_s\n            new_lcs_len = lcs_len\n            \n            while new_pos_s < N and S[new_pos_s] != c:\n                new_pos_s += 1\n            \n            if new_pos_s < N:\n                new_pos_s += 1\n                new_lcs_len += 1\n            \n            result = (result + solve(new_pos_s, pos_t + 1, new_lcs_len)) % MOD\n        \n        dp[(pos_s, pos_t, lcs_len)] = result\n        return result\n    \n    answers = []\n    \n    for target_k in range(N + 1):\n        dp.clear()\n        ans = solve(0, 0, 0)\n        answers.append(str(ans))\n    \n    return ' '.join(answers)",
  "model": "claude-sonnet-4"
}