{
  "task_id": "abc390_g",
  "task_description": "You are given a positive integer N.\nFor an integer sequence A=(A_1,A_2,\\ldots,A_N) of length N. Let f(A) be the integer obtained as follows:\n\n- Let S be an empty string.\n- For i=1,2,\\ldots,N in this order:\n- Let T be the decimal representation of A_i without leading zeros.\n- Append T to the end of S.\n\n\n- Interpret S as a decimal integer, and let that be f(A).\n\nFor example, if A=(1,20,34), then f(A)=12034.\nThere are N! permutations P of (1,2,\\ldots,N). Find the sum, modulo 998244353, of f(P) over all such permutations P.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN\n\nOutput\n\nPrint the sum, modulo 998244353, of f(P) over all permutations P of (1,2,\\ldots,N).\n\nConstraints\n\n\n- 1 \\le N \\le 2 \\times 10^5\n- All input values are integers.\n\nSample Input 1\n\n3\n\nSample Output 1\n\n1332\r\n\nThe six permutations of (1,2,3) are (1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,1,2), (3,2,1). Their f(P) values are 123,132,213,231,312,321. Therefore, print 123+132+213+231+312+321 = 1332.\n\nSample Input 2\n\n390\n\nSample Output 2\n\n727611652\r\n\nPrint the sum modulo 998244353.\n\nSample Input 3\n\n79223\n\nSample Output 3\n\n184895744",
  "llm_response": "def candidate_func(input_str):\n    MOD = 998244353\n    \n    N = int(input_str.strip())\n    \n    if N == 1:\n        return \"1\"\n    \n    # Precompute factorials and powers of 10\n    fact = [1] * (N + 1)\n    for i in range(1, N + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n        \n    pow10 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        pow10[i] = (pow10[i-1] * 10) % MOD\n    \n    # Compute the sum\n    # For each digit d (from 1 to N) and each position pos (from 1 to N):\n    # In how many permutations does digit d appear at position pos?\n    # Answer: (N-1)! permutations\n    # But we need to consider the contribution to the final number based on position\n    \n    # For a digit d at position pos (1-indexed), it contributes:\n    # d * 10^(N - pos) * (N-1)! to the sum\n    \n    # So total sum = (N-1)! * sum_{d=1}^N sum_{pos=1}^N d * 10^(N - pos)\n    # = (N-1)! * (sum_{d=1}^N d) * (sum_{pos=1}^N 10^(N - pos))\n    # = (N-1)! * (N*(N+1)/2) * (sum_{k=0}^{N-1} 10^k)\n    \n    # Sum of 10^k for k=0 to N-1 is (10^N - 1)/(10 - 1) = (10^N - 1)/9\n    # But we need to be careful with modular arithmetic\n    \n    # Since 9 and MOD are coprime, we can find modular inverse of 9\n    def modinv(a, mod):\n        return pow(a, mod - 2, mod)\n    \n    inv9 = modinv(9, MOD)\n    \n    sum_d = (N * (N + 1) // 2) % MOD\n    \n    # sum of 10^k for k=0 to N-1\n    if pow10[N] == 1:\n        sum_powers = N % MOD\n    else:\n        sum_powers = ((pow10[N] - 1 + MOD) % MOD * inv9) % MOD\n    \n    result = (fact[N-1] * sum_d) % MOD\n    result = (result * sum_powers) % MOD\n    \n    return str(result)",
  "model": "qwen3-coder"
}