{
  "task_id": "abc395_e",
  "task_description": "You are given a directed graph with N vertices and M edges.\r\nThe i-th edge (1 \\leq i \\leq M) is a directed edge from vertex u _ i to vertex v _ i.\nInitially, you are at vertex 1. You want to repeat the following operations until you reach vertex N:\n\n- Perform one of the two operations below:\n- Move along a directed edge from your current vertex. This incurs a cost of 1. More precisely, if you are at vertex v, choose a vertex u such that there is a directed edge from v to u, and move to vertex u.\n- Reverse the direction of all edges. This incurs a cost of X. More precisely, if and only if there was a directed edge from v to u immediately before this operation, there is a directed edge from u to v immediately after this operation.\n\n\n\nIt is guaranteed that, for the given graph, you can reach vertex N from vertex 1 by repeating these operations.\nFind the minimum total cost required to reach vertex N.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN M X\r\nu _ 1 v _ 1\r\nu _ 2 v _ 2\r\n\\vdots\r\nu _ M v _ M\n\nOutput\n\nPrint the minimum total cost required to reach vertex N.\n\nConstraints\n\n\n- 2 \\leq N \\leq 2 \\times 10^5\n- 1 \\leq M \\leq 2 \\times 10^5\n- 1 \\leq X \\leq 10^9\n- 1 \\leq u _ i \\leq N \\ (1 \\leq i \\leq M)\n- 1 \\leq v _ i \\leq N \\ (1 \\leq i \\leq M)\n- For the given graph, it is guaranteed that you can reach vertex N from vertex 1 by the operations described.\n- All input values are integers.\n\nSample Input 1\n\n5 6 5\r\n1 2\r\n2 4\r\n3 1\r\n3 5\r\n4 3\r\n5 2\n\nSample Output 1\n\n4\r\n\nThe given graph looks like this:\n\nYou can reach vertex 5 with a total cost of 4 by doing the following:\n\n- Move to vertex 2 at a cost of 1.\n- Move to vertex 4 at a cost of 1.\n- Move to vertex 3 at a cost of 1.\n- Move to vertex 5 at a cost of 1.\n\nIt is impossible to reach vertex 5 with a total cost of 3 or less, so print 4.\n\nSample Input 2\n\n5 6 1\r\n1 2\r\n2 4\r\n3 1\r\n3 5\r\n4 3\r\n5 2\n\nSample Output 2\n\n3\r\n\nThe graph is the same as in Sample 1, but the cost to reverse edges is different.\nYou can reach vertex 5 with a total cost of 3 as follows:\n\n- Move to vertex 2 at a cost of 1.\n- Reverse all edges at a cost of 1.\n- Move to vertex 5 at a cost of 1.\n\nIt is impossible to reach vertex 5 with a total cost of 2 or less, so print 3.\n\nSample Input 3\n\n8 7 613566756\r\n2 1\r\n2 3\r\n4 3\r\n4 5\r\n6 5\r\n6 7\r\n8 7\n\nSample Output 3\n\n4294967299\r\n\nNote that the answer may exceed the 32-bit integer range.\n\nSample Input 4\n\n20 13 5\r\n1 3\r\n14 18\r\n18 17\r\n12 19\r\n3 5\r\n4 6\r\n13 9\r\n8 5\r\n14 2\r\n20 18\r\n8 14\r\n4 9\r\n14 8\n\nSample Output 4\n\n21",
  "llm_response": "import sys\nfrom collections import deque\nimport heapq\n\ndef candidate_func(input_data):\n    lines = input_data.strip().split('\\n')\n    N, M, X = map(int, lines[0].split())\n    \n    edges = []\n    graph = [[] for _ in range(N+1)]\n    rev_graph = [[] for _ in range(N+1)]\n    \n    for i in range(1, M+1):\n        u, v = map(int, lines[i].split())\n        edges.append((u, v))\n        graph[u].append(v)\n        rev_graph[v].append(u)\n    \n    # 0-1 BFS on extended graph\n    # State: (vertex, reversed_flag) where reversed_flag is 0 or 1\n    dist = {}\n    pq = [(0, 1, 0)]  # (cost, vertex, reversed_flag)\n    dist[(1, 0)] = 0\n    \n    while pq:\n        cost, u, rev = heapq.heappop(pq)\n        if (u, rev) in dist and dist[(u, rev)] < cost:\n            continue\n            \n        if u == N:\n            return str(cost)\n            \n        # Move along an edge\n        if rev == 0:\n            for v in graph[u]:\n                if (v, rev) not in dist or dist[(v, rev)] > cost + 1:\n                    dist[(v, rev)] = cost + 1\n                    heapq.heappush(pq, (cost + 1, v, rev))\n        else:\n            for v in rev_graph[u]:\n                if (v, rev) not in dist or dist[(v, rev)] > cost + 1:\n                    dist[(v, rev)] = cost + 1\n                    heapq.heappush(pq, (cost + 1, v, rev))\n        \n        # Reverse all edges\n        new_rev = 1 - rev\n        if (u, new_rev) not in dist or dist[(u, new_rev)] > cost + X:\n            dist[(u, new_rev)] = cost + X\n            heapq.heappush(pq, (cost + X, u, new_rev))\n    \n    return \"0\"",
  "model": "qwen3-coder"
}