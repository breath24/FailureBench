{
  "task_id": "abc399_e",
  "task_description": "You are given a positive integer N and two strings S and T, each of length N and consisting of lowercase English letters.\nDetermine whether it is possible to make S identical to T by repeating the operation below any number of times (possibly zero). If it is possible, also find the minimum number of operations required.\n\n- Choose two lowercase English letters x, y and replace every occurrence of x in S with y.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN\r\nS\r\nT\n\nOutput\n\nIf it is possible to make S identical to T, print the minimum number of operations required. Otherwise, print -1.\n\nConstraints\n\n\n- 1\\leq N \\leq 2\\times 10^5\n- N is an integer.\n- Each of S and T is a string of length N, consisting of lowercase English letters.\n\nSample Input 1\n\n6\r\nafbfda\r\nbkckbb\n\nSample Output 1\n\n4\r\n\nBy performing the operation four times in the following way, you can make S identical to T:\n\n- Choose x= b and y= c. S becomes afcfda.\n- Choose x= a and y= b. S becomes bfcfdb.\n- Choose x= f and y= k. S becomes bkckdb.\n- Choose x= d and y= b. S becomes bkckbb, which is identical to T.\n\nIt cannot be done with fewer than four operations, so the minimum number of operations required is 4.\n\nSample Input 2\n\n4\r\nabac\r\nabac\n\nSample Output 2\n\n0\r\n\nS and T are already identical, so no operations are required.\n\nSample Input 3\n\n4\r\nabac\r\nabrc\n\nSample Output 3\n\n-1\r\n\nNo matter how you repeat the operation, it is impossible to make S identical to T.\n\nSample Input 4\n\n4\r\nabac\r\nbcba\n\nSample Output 4\n\n4",
  "llm_response": "def candidate_func(input_str):\n    lines = input_str.strip().split('\\n')\n    N = int(lines[0])\n    S = lines[1]\n    T = lines[2]\n    \n    if S == T:\n        return \"0\"\n    \n    from collections import defaultdict, deque\n    \n    # Create a mapping from characters in S to characters in T\n    mapping = defaultdict(set)\n    for i in range(N):\n        if S[i] != T[i]:\n            mapping[S[i]].add(T[i])\n    \n    # If no differences, return 0\n    if not mapping:\n        return \"0\"\n    \n    # Check if any character in S maps to multiple characters in T\n    for char_s in mapping:\n        if len(mapping[char_s]) > 1:\n            return \"-1\"\n    \n    # Build graph for transformations\n    graph = defaultdict(set)\n    reverse_graph = defaultdict(set)\n    all_chars = set()\n    \n    for char_s in mapping:\n        char_t = list(mapping[char_s])[0]\n        if char_s != char_t:\n            graph[char_s].add(char_t)\n            reverse_graph[char_t].add(char_s)\n            all_chars.add(char_s)\n            all_chars.add(char_t)\n    \n    # Check for cycles in the graph\n    in_degree = {char: 0 for char in all_chars}\n    for char in graph:\n        for neighbor in graph[char]:\n            in_degree[neighbor] += 1\n    \n    queue = deque()\n    for char in in_degree:\n        if in_degree[char] == 0:\n            queue.append(char)\n    \n    visited = set()\n    while queue:\n        current = queue.popleft()\n        visited.add(current)\n        for neighbor in graph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(visited) != len(all_chars):\n        return \"-1\"\n    \n    # Count the number of operations needed\n    visited_chars = set()\n    operations = 0\n    \n    for char in all_chars:\n        if char in visited_chars:\n            continue\n        if in_degree[char] == 0:\n            # Start of a chain\n            current = char\n            chain = []\n            while current and current not in visited_chars:\n                chain.append(current)\n                visited_chars.add(current)\n                # Find next in chain\n                next_chars = list(graph[current]) if current in graph else []\n                if next_chars:\n                    current = next_chars[0]\n                else:\n                    current = None\n            operations += len(chain) - 1\n        else:\n            # Part of a cycle or already processed\n            continue\n    \n    # For remaining characters not in chains, they must be self-mapped or in cycles\n    for char in all_chars:\n        if char not in visited_chars:\n            if char in graph and char in graph[char]:\n                # Self loop\n                visited_chars.add(char)\n            else:\n                # Part of a cycle\n                cycle = []\n                current = char\n                while current not in visited_chars:\n                    cycle.append(current)\n                    visited_chars.add(current)\n                    next_chars = list(graph[current]) if current in graph else []\n                    if next_chars:\n                        current = next_chars[0]\n                    else:\n                        current = None\n                        break\n                if len(cycle) > 1:\n                    operations += len(cycle) + 1\n    \n    return str(operations)",
  "model": "qwen3-coder"
}