{
  "task_id": "Mbpp/721",
  "task_description": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
  "llm_response": "def maxAverageOfPath(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    \n    n = len(matrix)\n    # dp[i][j] will store (max_sum, path_length) to reach cell (i,j)\n    dp = [[(float('-inf'), 0) for _ in range(n)] for _ in range(n)]\n    \n    # Base case\n    dp[0][0] = (matrix[0][0], 1)\n    \n    # Fill first row\n    for j in range(1, n):\n        dp[0][j] = (dp[0][j-1][0] + matrix[0][j], dp[0][j-1][1] + 1)\n    \n    # Fill first column\n    for i in range(1, n):\n        dp[i][0] = (dp[i-1][0][0] + matrix[i][0], dp[i-1][0][1] + 1)\n    \n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            # Coming from top\n            sum_from_top = dp[i-1][j][0] + matrix[i][j]\n            len_from_top = dp[i-1][j][1] + 1\n            \n            # Coming from left\n            sum_from_left = dp[i][j-1][0] + matrix[i][j]\n            len_from_left = dp[i][j-1][1] + 1\n            \n            # Choose the path with maximum average\n            avg_from_top = sum_from_top / len_from_top\n            avg_from_left = sum_from_left / len_from_left\n            \n            if avg_from_top > avg_from_left:\n                dp[i][j] = (sum_from_top, len_from_top)\n            else:\n                dp[i][j] = (sum_from_left, len_from_left)\n    \n    # Return the average of the best path to reach bottom-right cell\n    return dp[n-1][n-1][0] / dp[n-1][n-1][1]",
  "model": "qwen3-coder"
}