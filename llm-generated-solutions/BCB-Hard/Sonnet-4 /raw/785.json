{
  "task_id": "BigCodeBench/785",
  "instruct_prompt": "Archive all files that match a particular pattern and then delete the original files.\nNote that: This function will return the archive file path.\nThe function should output with:\n    archive_file (str): The archive file path.\nYou should write self-contained code starting with:\n```\nimport subprocess\nimport os\nimport glob\n# Constants\nARCHIVE_DIR = '/tmp/archive'\ndef task_func(pattern):\n```",
  "llm_response": "import subprocess\nimport os\nimport glob\nimport tarfile\nfrom datetime import datetime\nARCHIVE_DIR = '/tmp/archive'\ndef task_func(pattern):\n    \"\"\"\n    Archive all files that match a particular pattern and then delete the original files.\n    \n    Args:\n        pattern (str): File pattern to match (e.g., \"*.txt\", \"/path/to/files/*.log\")\n    \n    Returns:\n        str: The archive file path\n    \"\"\"\n    # Create archive directory if it doesn't exist\n    os.makedirs(ARCHIVE_DIR, exist_ok=True)\n    \n    # Find all files matching the pattern\n    matching_files = glob.glob(pattern)\n    \n    if not matching_files:\n        # If no files match, create an empty archive\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        archive_file = os.path.join(ARCHIVE_DIR, f\"archive_{timestamp}.tar.gz\")\n        \n        # Create empty tar.gz file\n        with tarfile.open(archive_file, 'w:gz') as tar:\n            pass\n        \n        return archive_file\n    \n    # Generate archive filename with timestamp\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    archive_file = os.path.join(ARCHIVE_DIR, f\"archive_{timestamp}.tar.gz\")\n    \n    # Create tar.gz archive\n    with tarfile.open(archive_file, 'w:gz') as tar:\n        for file_path in matching_files:\n            if os.path.isfile(file_path):\n                # Add file to archive with just the filename (not full path)\n                tar.add(file_path, arcname=os.path.basename(file_path))\n    \n    # Delete original files\n    for file_path in matching_files:\n        if os.path.isfile(file_path):\n            try:\n                os.remove(file_path)\n            except OSError as e:\n                print(f\"Warning: Could not delete {file_path}: {e}\")\n    \n    return archive_file",
  "model": "claude-sonnet-4"
}