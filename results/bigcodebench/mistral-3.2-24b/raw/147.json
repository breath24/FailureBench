{
  "task_id": "BigCodeBench/147",
  "instruct_prompt": "Scans a specified IP address range and checks if a specified port is open on each IP. The function returns a dictionary with IP addresses as keys and a boolean indicating the port's status (True if open, False otherwise).\nThe function should output with:\n    dict: A dictionary mapping IP addresses to their port status (True if open).\nYou should write self-contained code starting with:\n```\nimport socket\nfrom ipaddress import IPv4Network\nfrom threading import Thread\ndef task_func(ip_range, port):\n```",
  "llm_response": "import socket\nfrom ipaddress import IPv4Network\nfrom threading import Thread\ndef task_func(ip_range, port, timeout=1, result_dict=None, lock=None):\n    \"\"\"\n    Scans a specified IP address range and checks if a specified port is open on each IP.\n\n    Args:\n        ip_range (str): IP address range in CIDR notation (e.g., \"192.168.1.0/24\")\n        port (int): Port number to check\n        timeout (int): Timeout in seconds for socket connection attempts\n        result_dict (dict): Dictionary to store results (passed between threads)\n        lock (threading.Lock): Lock for thread-safe dictionary access\n\n    Returns:\n        dict: A dictionary mapping IP addresses to their port status (True if open)\n    \"\"\"\n    if result_dict is None:\n        result_dict = {}\n    if lock is None:\n        lock = Thread.alloc_lock()\n\n    def check_port(ip):\n        try:\n            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n                s.settimeout(timeout)\n                result = s.connect_ex((str(ip), port))\n                is_open = (result == 0)\n                with lock:\n                    result_dict[str(ip)] = is_open\n        except Exception as e:\n            with lock:\n                result_dict[str(ip)] = False\n\n    network = IPv4Network(ip_range, strict=False)\n    threads = []\n\n    for ip in network.hosts():\n        thread = Thread(target=check_port, args=(ip,))\n        threads.append(thread)\n        thread.start()\n\n    for thread in threads:\n        thread.join()\n\n    return result_dict",
  "model": "mistral-3.2-24b"
}