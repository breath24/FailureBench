{
  "task_id": "BigCodeBench/1040",
  "instruct_prompt": "Run a non-blocking echo server that appends the server's current time to received data and sends it back to the client, while handling exceptional conditions for each socket.\nThe function should output with:\n    str: A status message indicating the server's operation and run duration.\nYou should write self-contained code starting with:\n```\nimport socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n```",
  "llm_response": "import socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n    \"\"\"\n    Run a non-blocking echo server that appends the server's current time to received data\n    and sends it back to the client, while handling exceptional conditions for each socket.\n\n    Args:\n        server_address (str): Server address to bind to\n        server_port (int): Server port to bind to\n        buffer_size (int): Buffer size for socket operations\n        run_duration (int): Duration in seconds to run the server\n\n    Returns:\n        str: A status message indicating the server's operation and run duration.\n    \"\"\"\n    # Create a TCP/IP socket\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket.setblocking(False)\n\n    # Bind the socket to the port\n    server_address = (server_address, server_port)\n    try:\n        server_socket.bind(server_address)\n    except socket.error as e:\n        return f\"Failed to bind server: {e}\"\n\n    # Listen for incoming connections\n    server_socket.listen(5)\n\n    # Sockets from which we expect to read\n    inputs = [server_socket]\n    # Sockets to which we expect to write\n    outputs = []\n\n    # Outgoing message queues (socket:Queue)\n    message_queues = {}\n\n    start_time = datetime.now()\n    end_time = start_time + timedelta(seconds=run_duration)\n\n    try:\n        while datetime.now() < end_time:\n            # Wait for at least one socket to be ready for processing\n            readable, writable, exceptional = select.select(inputs, outputs, inputs, 1.0)\n\n            # Handle inputs\n            for s in readable:\n                if s is server_socket:\n                    # A \"readable\" server socket is ready to accept a connection\n                    connection, client_address = s.accept()\n                    connection.setblocking(False)\n                    inputs.append(connection)\n\n                    # Give the connection a queue for data we want to send\n                    message_queues[connection] = queue.Queue()\n                else:\n                    data = s.recv(buffer_size)\n                    if data:\n                        # A readable client socket has data\n                        current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                        response = f\"{data.decode()}[{current_time}]\".encode()\n                        message_queues[s].put(response)\n                        # Add output channel for response\n                        if s not in outputs:\n                            outputs.append(s)\n                    else:\n                        # Interpret empty result as closed connection\n                        if s in outputs:\n                            outputs.remove(s)\n                        inputs.remove(s)\n                        s.close()\n                        # Remove message queue\n                        del message_queues[s]\n\n            # Handle outputs\n            for s in writable:\n                try:\n                    next_msg = message_queues[s].get_nowait()\n                except queue.Empty:\n                    # No messages waiting so stop checking for writability\n                    outputs.remove(s)\n                else:\n                    s.send(next_msg)\n\n            # Handle exceptional conditions\n            for s in exceptional:\n                inputs.remove(s)\n                if s in outputs:\n                    outputs.remove(s)\n                s.close()\n                # Remove message queue\n                del message_queues[s]\n\n    except KeyboardInterrupt:\n        pass\n    finally:\n        # Clean up the connection\n        for s in inputs:\n            if s is not server_socket:\n                s.close()\n        server_socket.close()\n\n    duration = datetime.now() - start_time\n    return f\"Server ran for {duration.total_seconds():.2f} seconds, processed {len(message_queues)} connections\"",
  "model": "mistral-3.2-24b"
}