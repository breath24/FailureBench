{
  "task_id": "BigCodeBench/147",
  "instruct_prompt": "Scans a specified IP address range and checks if a specified port is open on each IP. The function returns a dictionary with IP addresses as keys and a boolean indicating the port's status (True if open, False otherwise).\nThe function should output with:\n    dict: A dictionary mapping IP addresses to their port status (True if open).\nYou should write self-contained code starting with:\n```\nimport socket\nfrom ipaddress import IPv4Network\nfrom threading import Thread\ndef task_func(ip_range, port):\n```",
  "llm_response": "import socket\nfrom ipaddress import IPv4Network\nfrom threading import Thread\ndef task_func(ip_range, port):\n    \"\"\"\n    Scans a specified IP address range and checks if a specified port is open on each IP.\n\n    Args:\n        ip_range (str): The IP address range to scan (e.g., \"192.168.1.0/24\").\n        port (int): The port number to check.\n\n    Returns:\n        dict: A dictionary mapping IP addresses to their port status (True if open).\n    \"\"\"\n\n    # Initialize an empty dictionary to store the results\n    results = {}\n\n    # Define a helper function to check a single IP address\n    def check_ip(ip):\n        try:\n            # Attempt to establish a connection to the IP address on the specified port\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(1)  # Set a timeout of 1 second\n            sock.connect((str(ip), port))\n            sock.close()\n            # If the connection is successful, the port is open\n            results[str(ip)] = True\n        except (socket.error, ConnectionRefusedError):\n            # If the connection fails, the port is closed\n            results[str(ip)] = False\n\n    # Create a list of IP addresses in the specified range\n    ip_addresses = [ip for ip in IPv4Network(ip_range)]\n\n    # Create and start a thread for each IP address\n    threads = []\n    for ip in ip_addresses:\n        thread = Thread(target=check_ip, args=(ip,))\n        thread.start()\n        threads.append(thread)\n\n    # Wait for all threads to finish\n    for thread in threads:\n        thread.join()\n\n    return results",
  "model": "llama-3.3-70b"
}