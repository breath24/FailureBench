{
  "task_id": "BigCodeBench/1040",
  "instruct_prompt": "Run a non-blocking echo server that appends the server's current time to received data and sends it back to the client, while handling exceptional conditions for each socket.\nThe function should output with:\n    str: A status message indicating the server's operation and run duration.\nYou should write self-contained code starting with:\n```\nimport socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n```",
  "llm_response": "import socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n    \"\"\"\n    Runs a non-blocking echo server that appends the server's current time to received data and sends it back to the client.\n    The server runs for a specified duration and handles exceptional conditions for each socket.\n\n    Parameters:\n    - server_address (str): The address to bind the server to. Default is \"localhost\".\n    - server_port (int): The port to bind the server to. Default is 12345.\n    - buffer_size (int): The buffer size for receiving data. Default is 1024.\n    - run_duration (int): The duration in seconds for which the server should run. Default is 5.\n\n    Returns:\n    - str: A status message indicating the server's operation and run duration.\n    \"\"\"\n    # Create a TCP/IP socket\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.setblocking(False)\n    \n    # Bind the socket to the port\n    server_socket.bind((server_address, server_port))\n    \n    # Listen for incoming connections\n    server_socket.listen(5)\n    \n    # Sockets from which we expect to read\n    inputs = [server_socket]\n    # Sockets to which we expect to write\n    outputs = []\n    # Outgoing message queues (socket:Queue)\n    message_queues = {}\n    \n    start_time = datetime.now()\n    end_time = start_time + timedelta(seconds=run_duration)\n    \n    print(f\"Server started on {server_address}:{server_port}. Running for {run_duration} seconds...\")\n    \n    while datetime.now() < end_time:\n        # Wait for at least one of the sockets to be ready for processing\n        readable, writable, exceptional = select.select(inputs, outputs, inputs, 1.0)\n        \n        # Handle readable sockets\n        for s in readable:\n            if s is server_socket:\n                # A \"readable\" server socket is ready to accept a connection\n                try:\n                    connection, client_address = s.accept()\n                    connection.setblocking(False)\n                    inputs.append(connection)\n                    message_queues[connection] = queue.Queue()\n                    print(f\"New connection from {client_address}\")\n                except socket.error as e:\n                    print(f\"Error accepting connection: {e}\")\n            else:\n                # A \"readable\" client socket has data to read\n                try:\n                    data = s.recv(buffer_size)\n                    if data:\n                        # Append server's current time to the received data\n                        response = f\"{data.decode()} - Server time: {datetime.now()}\"\n                        message_queues[s].put(response.encode())\n                        # Add output channel for response\n                        if s not in outputs:\n                            outputs.append(s)\n                    else:\n                        # Interpret empty result as closed connection\n                        print(f\"Closing connection from {s.getpeername()} after reading no data\")\n                        # Stop listening for input on the connection\n                        if s in outputs:\n                            outputs.remove(s)\n                        inputs.remove(s)\n                        s.close()\n                        # Remove message queue\n                        del message_queues[s]\n                except socket.error as e:\n                    print(f\"Error reading from socket: {e}\")\n                    # Stop listening for input on the connection\n                    if s in outputs:\n                        outputs.remove(s)\n                    inputs.remove(s)\n                    s.close()\n                    # Remove message queue\n                    del message_queues[s]\n        \n        # Handle writable sockets\n        for s in writable:\n            try:\n                next_msg = message_queues[s].get_nowait()\n            except queue.Empty:\n                # No messages waiting so stop checking for writability\n                outputs.remove(s)\n            except KeyError:\n                # Socket was closed and removed from message_queues\n                pass\n            else:\n                try:\n                    s.send(next_msg)\n                except socket.error as e:\n                    print(f\"Error sending data: {e}\")\n                    # Stop listening for input on the connection\n                    if s in outputs:\n                        outputs.remove(s)\n                    inputs.remove(s)\n                    s.close()\n                    # Remove message queue\n                    del message_queues[s]\n        \n        # Handle exceptional conditions\n        for s in exceptional:\n            print(f\"Handling exceptional condition for {s.getpeername()}\")\n            # Stop listening for input on the connection\n            inputs.remove(s)\n            if s in outputs:\n                outputs.remove(s)\n            s.close()\n            # Remove message queue\n            del message_queues[s]\n    \n    # Clean up all connections\n    for s in inputs:\n        s.close()\n    for s in outputs:\n        s.close()\n    message_queues.clear()\n    \n    return f\"Server ran for {run_duration} seconds and is now stopped.\"",
  "model": "deepseek-chat-v3-0324"
}