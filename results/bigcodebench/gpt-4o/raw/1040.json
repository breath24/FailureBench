{
  "task_id": "BigCodeBench/1040",
  "instruct_prompt": "Run a non-blocking echo server that appends the server's current time to received data and sends it back to the client, while handling exceptional conditions for each socket.\nThe function should output with:\n    str: A status message indicating the server's operation and run duration.\nYou should write self-contained code starting with:\n```\nimport socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n```",
  "llm_response": "import socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n    # Create a TCP/IP socket\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setblocking(0)\n\n    # Bind the socket to the address and port\n    server.bind((server_address, server_port))\n\n    # Listen for incoming connections\n    server.listen(5)\n\n    # Sockets from which we expect to read\n    inputs = [server]\n\n    # Sockets to which we expect to write\n    outputs = []\n\n    # Outgoing message queues (socket:Queue)\n    message_queues = {}\n\n    # Record the start time\n    start_time = datetime.now()\n\n    # Run the server for the specified duration\n    end_time = start_time + timedelta(seconds=run_duration)\n\n    try:\n        while datetime.now() < end_time:\n            # Wait for at least one of the sockets to be ready for processing\n            readable, writable, exceptional = select.select(inputs, outputs, inputs, 1)\n\n            # Handle inputs\n            for s in readable:\n                if s is server:\n                    # A \"readable\" server socket is ready to accept a connection\n                    connection, client_address = s.accept()\n                    connection.setblocking(0)\n                    inputs.append(connection)\n                    message_queues[connection] = queue.Queue()\n                else:\n                    data = s.recv(buffer_size)\n                    if data:\n                        # A readable client socket has data\n                        current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                        response = data.decode() + \" \" + current_time\n                        message_queues[s].put(response.encode())\n                        if s not in outputs:\n                            outputs.append(s)\n                    else:\n                        # Interpret empty result as closed connection\n                        if s in outputs:\n                            outputs.remove(s)\n                        inputs.remove(s)\n                        s.close()\n                        del message_queues[s]\n\n            # Handle outputs\n            for s in writable:\n                try:\n                    next_msg = message_queues[s].get_nowait()\n                except queue.Empty:\n                    outputs.remove(s)\n                else:\n                    s.send(next_msg)\n\n            # Handle \"exceptional conditions\"\n            for s in exceptional:\n                inputs.remove(s)\n                if s in outputs:\n                    outputs.remove(s)\n                s.close()\n                del message_queues[s]\n\n    finally:\n        # Clean up the connection\n        for s in inputs:\n            s.close()\n        for s in outputs:\n            s.close()\n\n    return f\"Server ran for {run_duration} seconds and is now closed.\"",
  "model": "gpt-4o"
}