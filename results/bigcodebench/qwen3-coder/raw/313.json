{
  "task_id": "BigCodeBench/313",
  "instruct_prompt": "Organize files in a directory based on the first text that is not enclosed in square brackets. Move the files to subdirectories named after this text. If no matching text is found, the file is not moved.\nThe function should output with:\n    tuple:\n    str: The directory path with organized files.\n    dict: A dictionary where keys are the created subdirectories and values are lists of files moved to them.\nYou should write self-contained code starting with:\n```\nimport re\nimport os\nimport shutil\nfrom datetime import datetime\ndef task_func(directory):\n```",
  "llm_response": "import re\nimport os\nimport shutil\nfrom datetime import datetime\ndef task_func(directory):\n    \"\"\"\n    Organize files in a directory based on the first text that is not enclosed in square brackets.\n    Move the files to subdirectories named after this text. If no matching text is found, \n    the file is not moved.\n    \n    Args:\n        directory (str): Path to the directory to organize\n        \n    Returns:\n        tuple: (directory_path, dict_of_moved_files)\n    \"\"\"\n    # Dictionary to track moved files\n    moved_files = {}\n    \n    # Ensure directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory {directory} does not exist\")\n    \n    # Get all files in the directory\n    files = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]\n    \n    for filename in files:\n        file_path = os.path.join(directory, filename)\n        \n        # Extract the first text that is not enclosed in square brackets\n        # This regex finds text before the first [ or after the last ] or between ] and [\n        match = re.search(r'^([^[]*)\\[|\\]([^[]*)\\[|\\]([^[]*)$', filename)\n        \n        # If no brackets at all, use the whole filename (without extension) as the category\n        if '[' not in filename and ']' not in filename:\n            # Use filename without extension as category\n            category = os.path.splitext(filename)[0]\n            if not category:  # Handle files that are only extensions\n                category = filename\n        elif match:\n            # Get the first non-empty group\n            category = next((group for group in match.groups() if group), None)\n            if category:\n                category = category.strip()\n        else:\n            # Try another approach: find text before first [\n            before_first_bracket = re.search(r'^([^\\[]*?)(?=\\[)', filename)\n            if before_first_bracket:\n                category = before_first_bracket.group(1).strip()\n            else:\n                # Find text between ] and [\n                between_brackets = re.search(r'\\]([^\\[]*?)\\[', filename)\n                if between_brackets:\n                    category = between_brackets.group(1).strip()\n                else:\n                    # Find text after last ]\n                    after_last_bracket = re.search(r'\\]([^\\]]*)$', filename)\n                    if after_last_bracket:\n                        category = after_last_bracket.group(1).strip()\n                    else:\n                        category = None\n        \n        # If we found a category and it's not empty, move the file\n        if category and category.strip():\n            # Clean the category name to make it a valid directory name\n            # Remove characters that are invalid for directory names\n            category = re.sub(r'[<>:\"/\\\\|?*]', '', category).strip()\n            \n            # If category is empty after cleaning, skip\n            if not category:\n                continue\n                \n            # Create subdirectory\n            subdirectory_path = os.path.join(directory, category)\n            if not os.path.exists(subdirectory_path):\n                os.makedirs(subdirectory_path)\n            \n            # Move file\n            destination_path = os.path.join(subdirectory_path, filename)\n            \n            # If file already exists in destination, skip to avoid overwriting\n            if not os.path.exists(destination_path):\n                shutil.move(file_path, destination_path)\n                \n                # Track moved files\n                if category not in moved_files:\n                    moved_files[category] = []\n                moved_files[category].append(filename)\n    \n    return (directory, moved_files)",
  "model": "qwen3-coder"
}