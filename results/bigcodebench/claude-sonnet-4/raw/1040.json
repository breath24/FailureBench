{
  "task_id": "BigCodeBench/1040",
  "instruct_prompt": "Run a non-blocking echo server that appends the server's current time to received data and sends it back to the client, while handling exceptional conditions for each socket.\nThe function should output with:\n    str: A status message indicating the server's operation and run duration.\nYou should write self-contained code starting with:\n```\nimport socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n```",
  "llm_response": "import socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n    \"\"\"\n    Run a non-blocking echo server that appends the server's current time to received data\n    and sends it back to the client, while handling exceptional conditions for each socket.\n    \n    Args:\n        server_address (str): Server IP address\n        server_port (int): Server port number\n        buffer_size (int): Buffer size for socket operations\n        run_duration (int): Duration to run the server in seconds\n    \n    Returns:\n        str: A status message indicating the server's operation and run duration\n    \"\"\"\n    # Create server socket\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket.setblocking(False)\n    \n    try:\n        # Bind and listen\n        server_socket.bind((server_address, server_port))\n        server_socket.listen(5)\n        \n        # Track sockets and message queues\n        inputs = [server_socket]\n        outputs = []\n        message_queues = {}\n        \n        # Track server statistics\n        start_time = datetime.now()\n        end_time = start_time + timedelta(seconds=run_duration)\n        clients_served = 0\n        messages_processed = 0\n        \n        while datetime.now() < end_time:\n            # Use select with timeout to check for activity\n            timeout = 1.0  # 1 second timeout\n            readable, writable, exceptional = select.select(inputs, outputs, inputs, timeout)\n            \n            # Handle readable sockets\n            for sock in readable:\n                if sock is server_socket:\n                    # Accept new connection\n                    try:\n                        client_socket, client_address = sock.accept()\n                        client_socket.setblocking(False)\n                        inputs.append(client_socket)\n                        message_queues[client_socket] = queue.Queue()\n                        clients_served += 1\n                    except socket.error:\n                        continue\n                else:\n                    # Handle client data\n                    try:\n                        data = sock.recv(buffer_size)\n                        if data:\n                            # Append current time to received data\n                            current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S.%f\")\n                            response = f\"{data.decode('utf-8')} [Server Time: {current_time}]\"\n                            message_queues[sock].put(response.encode('utf-8'))\n                            messages_processed += 1\n                            \n                            # Add to outputs if not already there\n                            if sock not in outputs:\n                                outputs.append(sock)\n                        else:\n                            # Client disconnected\n                            if sock in outputs:\n                                outputs.remove(sock)\n                            inputs.remove(sock)\n                            sock.close()\n                            del message_queues[sock]\n                    except socket.error:\n                        # Handle socket errors\n                        if sock in outputs:\n                            outputs.remove(sock)\n                        if sock in inputs:\n                            inputs.remove(sock)\n                        sock.close()\n                        if sock in message_queues:\n                            del message_queues[sock]\n            \n            # Handle writable sockets\n            for sock in writable:\n                try:\n                    if sock in message_queues and not message_queues[sock].empty():\n                        next_msg = message_queues[sock].get_nowait()\n                        sock.send(next_msg)\n                    else:\n                        # No messages to send, remove from outputs\n                        outputs.remove(sock)\n                except queue.Empty:\n                    outputs.remove(sock)\n                except socket.error:\n                    # Handle socket errors\n                    if sock in outputs:\n                        outputs.remove(sock)\n                    if sock in inputs:\n                        inputs.remove(sock)\n                    sock.close()\n                    if sock in message_queues:\n                        del message_queues[sock]\n            \n            # Handle exceptional conditions\n            for sock in exceptional:\n                if sock in inputs:\n                    inputs.remove(sock)\n                if sock in outputs:\n                    outputs.remove(sock)\n                sock.close()\n                if sock in message_queues:\n                    del message_queues[sock]\n        \n        # Clean up remaining connections\n        for sock in inputs:\n            if sock is not server_socket:\n                sock.close()\n        \n        actual_duration = (datetime.now() - start_time).total_seconds()\n        \n        return (f\"Echo server ran for {actual_duration:.2f} seconds on \"\n                f\"{server_address}:{server_port}. Served {clients_served} clients \"\n                f\"and processed {messages_processed} messages.\")\n    \n    except Exception as e:\n        return f\"Server error: {str(e)}\"\n    \n    finally:\n        server_socket.close()",
  "model": "claude-sonnet-4"
}