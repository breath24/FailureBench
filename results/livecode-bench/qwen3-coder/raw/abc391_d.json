{
  "task_id": "abc391_d",
  "llm_response": "import sys\nfrom collections import defaultdict\nimport bisect\n\ndef candidate_func(input_data):\n    lines = input_data.strip().split('\\n')\n    idx = 0\n    N, W = map(int, lines[idx].split())\n    idx += 1\n    \n    blocks = []\n    pos_to_index = {}\n    for i in range(N):\n        x, y = map(int, lines[idx].split())\n        blocks.append((x, y))\n        pos_to_index[(x, y)] = i + 1\n        idx += 1\n    \n    Q = int(lines[idx])\n    idx += 1\n    queries = []\n    for i in range(Q):\n        t, a = map(int, lines[idx].split())\n        queries.append((t, a))\n        idx += 1\n    \n    # Group blocks by column\n    col_blocks = defaultdict(list)\n    for i, (x, y) in enumerate(blocks):\n        col_blocks[x].append(y)\n    \n    # Sort each column's blocks by y (ascending)\n    for x in col_blocks:\n        col_blocks[x].sort()\n    \n    # Precompute for each block: when it disappears\n    disappear_time = [0] * (N + 1)\n    \n    # For each column, simulate the falling process\n    for x in col_blocks:\n        ys = col_blocks[x]\n        # We process from bottom to top\n        # For each block, determine when it can fall\n        n_blocks = len(ys)\n        # We'll compute fall times for each block in this column\n        # fall_time[i] = time when block at ys[i] starts falling\n        fall_time = [0] * n_blocks\n        \n        # Process from bottom to top\n        for i in range(n_blocks):\n            y = ys[i]\n            # If it's at the bottom, it never falls (unless full row)\n            if i == 0:\n                fall_time[i] = 0\n            else:\n                # It can fall if the block below it is gone\n                # The block below is ys[i-1]\n                # It starts falling at fall_time[i-1]\n                # And disappears at fall_time[i-1] + 1\n                # So this block can start falling at fall_time[i-1] + 1\n                fall_time[i] = fall_time[i-1] + 1\n        \n        # Now determine when each block disappears\n        for i in range(n_blocks):\n            idx_block = pos_to_index[(x, ys[i])]\n            disappear_time[idx_block] = fall_time[i] + 1\n    \n    # Count how many blocks disappear at each time\n    disappear_count = defaultdict(int)\n    for i in range(1, N + 1):\n        disappear_count[disappear_time[i]] += 1\n    \n    # Compute prefix sum: total blocks disappeared by time t\n    times = sorted(disappear_count.keys())\n    prefix_disappear = {}\n    total = 0\n    for t in times:\n        total += disappear_count[t]\n        prefix_disappear[t] = total\n    \n    # Function to get number of blocks disappeared by time t\n    def blocks_disappeared_by(t):\n        if not times:\n            return 0\n        # Find largest time <= t\n        pos = bisect.bisect_right(times, t) - 1\n        if pos < 0:\n            return 0\n        return prefix_disappear[times[pos]]\n    \n    # Answer queries\n    result = []\n    for t, a in queries:\n        # Block a disappears at time disappear_time[a]\n        # So it exists at time t+0.5 if t+0.5 < disappear_time[a]\n        # That is, if t < disappear_time[a]\n        if t < disappear_time[a]:\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n    \n    return '\\n'.join(result)",
  "model": "qwen3-coder",
  "task_description": "There is a grid with 10^9 rows and W columns. The cell at the x-th column from the left and the y-th row from the bottom is denoted by (x,y).\nThere are N blocks. Each block is a 1 \\times 1 square, and block i-th (1 \\leq i \\leq N) is located at cell (X_i,Y_i) at time 0.\nAt times t=1,2,\\dots,10^{100}, the blocks are moved according to the following rules:\n\n- If the entire bottom row is filled with blocks, then all blocks in the bottom row are removed.\n- For each remaining block, in order from bottom to top, perform the following:\n- If the block is in the bottom row, or if there is a block in the cell immediately below it, do nothing.\n- Otherwise, move the block one cell downward.\n\n\n\nYou are given Q queries. For the j-th query (1 \\leq j \\leq Q), answer whether block A_j exists at time T_j+0.5.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN W\nX_1 Y_1\nX_2 Y_2\n\\vdots\nX_N Y_N\nQ\nT_1 A_1\nT_2 A_2\n\\vdots\nT_Q A_Q\n\nOutput\n\nPrint Q lines. The i-th line should contain Yes if block A_i exists at time T_i+0.5, and No otherwise.\n\nConstraints\n\n\n- 1 \\leq N \\leq 2 \\times 10^5\n- 1 \\leq W \\leq N\n- 1 \\leq X_i \\leq W\n- 1 \\leq Y_i \\leq 10^9\n- (X_i,Y_i) \\neq (X_j,Y_j) if i \\neq j.\n- 1 \\leq Q \\leq 2 \\times 10^5\n- 1 \\leq T_j \\leq 10^9\n- 1 \\leq A_j \\leq N\n- All input values are integers.\n\nSample Input 1\n\n5 3\n1 1\n1 2\n2 2\n3 2\n2 3\n6\n1 1\n1 2\n2 3\n2 5\n3 4\n3 5\n\nSample Output 1\n\nYes\nYes\nNo\nYes\nNo\nYes\n\nThe positions of the blocks change as follows: (\"\u6642\u523b\" means \"time.\")\n\n\n- Query 1: At time 1.5, block 1 exists, so the answer is Yes.\n- Query 2: At time 1.5, block 2 exists, so the answer is Yes.\n- Query 3: Block 3 disappears at time 2, so it does not exist at time 2.5, and the answer is No.\n\nSample Input 2\n\n3 2\n1 1\n2 1\n1 2\n4\n1 1\n1 2\n1 3\n2 3\n\nSample Output 2\n\nNo\nNo\nYes\nYes"
}