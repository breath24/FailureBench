{
  "task_id": "arc195_e",
  "llm_response": "import sys\nfrom collections import defaultdict\n\ndef candidate_func(input_data):\n    MOD = 998244353\n    \n    lines = input_data.strip().split('\\n')\n    N, Q = map(int, lines[0].split())\n    A = list(map(int, lines[1].split()))\n    \n    queries = []\n    for i in range(2, 2 + Q):\n        u, v = map(int, lines[i].split())\n        queries.append((u, v))\n    \n    # Precompute factorials and inverse factorials\n    max_n = N\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    # Function to compute modular inverse using Fermat's little theorem\n    def modinv(x):\n        return pow(x, MOD-2, MOD)\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = modinv(fact[max_n])\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n    \n    # Compute contribution of each edge weight\n    # For edge from i to parent, the number of trees where this edge is on the path between u and v\n    # is (number of ways to arrange parents of 2..i-1) * (number of ways to arrange parents of i+1..N)\n    # such that u and v are in different subtrees separated by this edge\n    \n    # Precompute the total sum for each query\n    # The key insight is that for each edge (i, P_i) with weight A[i-2], \n    # we need to count how many trees have u and v in different components when this edge is removed\n    \n    # For each node i (2 to N), the edge from i to its parent contributes A[i-2]\n    # The number of trees where this edge is on the path between u and v is:\n    # (i-2)! * (N-i)! * (number of ways u and v are in different parts)\n    \n    results = []\n    \n    for u, v in queries:\n        total = 0\n        # For each possible edge in the tree\n        for i in range(2, N+1):\n            weight = A[i-2]\n            # Count how many trees have the edge from i to parent on the path from u to v\n            # This happens when u and v are in different components after removing this edge\n            # Component 1: nodes 1..i-1 including the parent of i\n            # Component 2: nodes i..N\n            \n            # In any valid tree, node i must have parent in 1..i-1\n            # The number of valid parent assignments for nodes 2..i-1 is (i-2)!\n            # The number of valid parent assignments for nodes i+1..N is (N-i)!\n            \n            # For u and v to be separated by the edge from i to its parent:\n            # One of u,v must be in {1,2,...,i-1} and the other in {i,i+1,...,N}\n            \n            if u < i and v >= i:\n                # u is in first component, v is in second component\n                count = (fact[i-2] * fact[N-i]) % MOD\n                total = (total + (weight * count) % MOD) % MOD\n            elif v < i and u >= i:\n                # v is in first component, u is in second component\n                count = (fact[i-2] * fact[N-i]) % MOD\n                total = (total + (weight * count) % MOD) % MOD\n                \n        results.append(str(total))\n    \n    return '\\n'.join(results)",
  "model": "qwen3-coder",
  "task_description": "There is an integer sequence A = (A_2,A_3,\\ldots,A_N). Also, for an integer sequence P=(P_2, P_3, \\ldots ,P_N) where 1 \\leq P_i \\leq i-1 for each i (2 \\leq i \\leq N), define the weighted tree T(P) with N vertices, rooted at vertex 1, as follows:\n\n- A rooted tree where, for each i (2 \\leq i \\leq N), the parent of i is P_i, and the weight of the edge between i and P_i is A_i.\n\nYou are given Q queries. Process them in order. The i-th query is as follows:\n\n- You are given integers u_i and v_i, each between 1 and N. For each of the possible (N-1)! sequences P, take the tree T(P) and consider the distance between vertices u_i and v_i in this tree. Output the sum, modulo 998244353, of these distances over all T(P). Here, the distance between two vertices u_i and v_i is the sum of the weights of the edges on the unique path (not visiting the same vertex more than once) that connects them.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN Q\nA_2 A_3 \\ldots A_N\nu_1 v_1\nu_2 v_2\n\\vdots\nu_Q v_Q\n\nOutput\n\nPrint Q lines. The i-th line should contain the answer to the i-th query.\n\nConstraints\n\n\n- 2 \\leq N \\leq 2 \\times 10^5\n- 1 \\leq Q \\leq 2 \\times 10^5\n- 1 \\leq A_i \\leq 10^9\n- 1 \\leq u_i < v_i \\leq N\n- All input values are integers.\n\nSample Input 1\n\n3 2\n1 1\n1 2\n1 3\n\nSample Output 1\n\n2\n3\n\n\n- If P = (1,1), then in the tree T(P), the distance between vertices 1 and 2 is 1, and the distance between vertices 1 and 3 is 1.\n- If P = (1,2), then in the tree T(P), the distance between vertices 1 and 2 is 1, and the distance between vertices 1 and 3 is 2.\n\nTherefore, the total distance between vertices 1 and 2 over all T(P) is 2, and the total distance between vertices 1 and 3 over all T(P) is 3.\n\nSample Input 2\n\n2 1\n100\n1 2\n\nSample Output 2\n\n100\n\nSample Input 3\n\n9 6\n765689282 93267307 563699854 951829154 801512848 389123318 924504746 596035433\n3 8\n2 5\n5 8\n2 9\n8 9\n5 7\n\nSample Output 3\n\n55973424\n496202632\n903509579\n343265517\n550981449\n68482696\n\nRemember to take the sum modulo 998244353."
}