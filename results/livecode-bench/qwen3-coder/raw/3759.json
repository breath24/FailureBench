{
  "task_id": "3759",
  "llm_response": "import heapq\n\ndef findMaxSum(nums1, nums2, k):\n    n = len(nums1)\n    indexed_nums1 = [(nums1[i], i) for i in range(n)]\n    indexed_nums1.sort()\n    \n    answer = [0] * n\n    max_heap = []\n    \n    for i in range(n):\n        val1, orig_idx = indexed_nums1[i]\n        \n        if i > 0:\n            j = i - 1\n            while j >= 0 and indexed_nums1[j][0] < val1:\n                idx = indexed_nums1[j][1]\n                heapq.heappush(max_heap, -nums2[idx])\n                j -= 1\n            \n            if len(max_heap) > k:\n                while len(max_heap) > k:\n                    heapq.heappop(max_heap)\n            \n            total = 0\n            temp_heap = []\n            for _ in range(min(k, len(max_heap))):\n                total += (-heapq.heappop(max_heap))\n                temp_heap.append(-(-nums2[indexed_nums1[j+1+_][1]]))\n            \n            answer[orig_idx] = total\n            \n            for item in temp_heap:\n                heapq.heappush(max_heap, -item)\n        else:\n            answer[orig_idx] = 0\n    \n    return answer\n\ndef findMaxSum(nums1, nums2, k):\n    n = len(nums1)\n    indexed_nums1 = [(nums1[i], i) for i in range(n)]\n    indexed_nums1.sort()\n    \n    answer = [0] * n\n    max_heap = []\n    \n    for i in range(n):\n        val1, orig_idx = indexed_nums1[i]\n        \n        while max_heap and max_heap[0][1] >= i:\n            heapq.heappop(max_heap)\n            \n        total = 0\n        count = 0\n        temp_list = []\n        for val, idx in max_heap:\n            if indexed_nums1[idx][0] < val1:\n                temp_list.append((val, idx))\n        \n        temp_list.sort(reverse=True)\n        for val, idx in temp_list:\n            if count < k:\n                total += val\n                count += 1\n            else:\n                break\n                \n        answer[orig_idx] = total\n        \n        heapq.heappush(max_heap, (nums2[orig_idx], orig_idx))\n    \n    return answer",
  "model": "qwen3-coder",
  "task_description": "You are given two integer arrays, nums1 and nums2, both of length n, along with a positive integer k.\nFor each index i from 0 to n - 1, perform the following:\n\nFind all indices j where nums1[j] is less than nums1[i].\nChoose at most k values of nums2[j] at these indices to maximize the total sum.\n\nReturn an array answer of size n, where answer[i] represents the result for the corresponding index i.\n \nExample 1:\n\nInput: nums1 = [4,2,1,5,3], nums2 = [10,20,30,40,50], k = 2\nOutput: [80,30,0,80,50]\nExplanation:\n\nFor i = 0: Select the 2 largest values from nums2 at indices [1, 2, 4] where nums1[j] < nums1[0], resulting in 50 + 30 = 80.\nFor i = 1: Select the 2 largest values from nums2 at index [2] where nums1[j] < nums1[1], resulting in 30.\nFor i = 2: No indices satisfy nums1[j] < nums1[2], resulting in 0.\nFor i = 3: Select the 2 largest values from nums2 at indices [0, 1, 2, 4] where nums1[j] < nums1[3], resulting in 50 + 30 = 80.\nFor i = 4: Select the 2 largest values from nums2 at indices [1, 2] where nums1[j] < nums1[4], resulting in 30 + 20 = 50.\n\n\nExample 2:\n\nInput: nums1 = [2,2,2,2], nums2 = [3,1,2,3], k = 1\nOutput: [0,0,0,0]\nExplanation:\nSince all elements in nums1 are equal, no indices satisfy the condition nums1[j] < nums1[i] for any i, resulting in 0 for all positions.\n\n \nConstraints:\n\nn == nums1.length == nums2.length\n1 <= n <= 10^5\n1 <= nums1[i], nums2[i] <= 10^6\n1 <= k <= n"
}