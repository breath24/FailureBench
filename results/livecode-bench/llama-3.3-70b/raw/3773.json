{
  "task_id": "3773",
  "llm_response": "import heapq\n\ndef minimumPairRemoval(nums):\n    pq = []\n    for i in range(len(nums) - 1):\n        heapq.heappush(pq, (nums[i] + nums[i + 1], i))\n    count = 0\n    while pq:\n        s, i = heapq.heappop(pq)\n        if i < len(nums) - 1 and nums[i] + nums[i + 1] == s:\n            count += 1\n            nums[i] = s\n            if i > 0:\n                heapq.heappush(pq, (nums[i - 1] + nums[i], i - 1))\n            if i < len(nums) - 2:\n                heapq.heappush(pq, (nums[i] + nums[i + 2], i))\n            nums.pop(i + 1)\n        if nums == sorted(nums):\n            break\n    return count",
  "model": "llama-3.3-70b",
  "task_description": "Given an array nums, you can perform the following operation any number of times:\n\nSelect the adjacent pair with the minimum sum in nums. If multiple such pairs exist, choose the leftmost one.\nReplace the pair with their sum.\n\nReturn the minimum number of operations needed to make the array non-decreasing.\nAn array is said to be non-decreasing if each element is greater than or equal to its previous element (if it exists).\n \nExample 1:\n\nInput: nums = [5,2,3,1]\nOutput: 2\nExplanation:\n\nThe pair (3,1) has the minimum sum of 4. After replacement, nums = [5,2,4].\nThe pair (2,4) has the minimum sum of 6. After replacement, nums = [5,6].\n\nThe array nums became non-decreasing in two operations.\n\nExample 2:\n\nInput: nums = [1,2,2]\nOutput: 0\nExplanation:\nThe array nums is already sorted.\n\n \nConstraints:\n\n1 <= nums.length <= 50\n-1000 <= nums[i] <= 1000"
}