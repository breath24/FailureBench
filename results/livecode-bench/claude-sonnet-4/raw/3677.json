{
  "task_id": "3677",
  "llm_response": "def maximumAmount(coins):\n    m, n = len(coins), len(coins[0])\n    \n    dp = [[[-float('inf')] * 3 for _ in range(n)] for _ in range(m)]\n    \n    dp[0][0][0] = coins[0][0] if coins[0][0] >= 0 else 0\n    if coins[0][0] < 0:\n        dp[0][0][1] = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            \n            for k in range(3):\n                if i > 0 and dp[i-1][j][k] != -float('inf'):\n                    if coins[i][j] >= 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k] + coins[i][j])\n                    else:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k] + coins[i][j])\n                        if k > 0:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1])\n                \n                if j > 0 and dp[i][j-1][k] != -float('inf'):\n                    if coins[i][j] >= 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k] + coins[i][j])\n                    else:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k] + coins[i][j])\n                        if k > 0:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1])\n    \n    return max(dp[m-1][n-1])",
  "model": "claude-sonnet-4",
  "task_description": "You are given an m x n grid. A robot starts at the top-left corner of the grid (0, 0) and wants to reach the bottom-right corner (m - 1, n - 1). The robot can move either right or down at any point in time.\nThe grid contains a value coins[i][j] in each cell:\n\nIf coins[i][j] >= 0, the robot gains that many coins.\nIf coins[i][j] < 0, the robot encounters a robber, and the robber steals the absolute value of coins[i][j] coins.\n\nThe robot has a special ability to neutralize robbers in at most 2 cells on its path, preventing them from stealing coins in those cells.\nNote: The robot's total coins can be negative.\nReturn the maximum profit the robot can gain on the route.\n \nExample 1:\n\nInput: coins = [[0,1,-1],[1,-2,3],[2,-3,4]]\nOutput: 8\nExplanation:\nAn optimal path for maximum coins is:\n\nStart at (0, 0) with 0 coins (total coins = 0).\nMove to (0, 1), gaining 1 coin (total coins = 0 + 1 = 1).\nMove to (1, 1), where there's a robber stealing 2 coins. The robot uses one neutralization here, avoiding the robbery (total coins = 1).\nMove to (1, 2), gaining 3 coins (total coins = 1 + 3 = 4).\nMove to (2, 2), gaining 4 coins (total coins = 4 + 4 = 8).\n\n\nExample 2:\n\nInput: coins = [[10,10,10],[10,10,10]]\nOutput: 40\nExplanation:\nAn optimal path for maximum coins is:\n\nStart at (0, 0) with 10 coins (total coins = 10).\nMove to (0, 1), gaining 10 coins (total coins = 10 + 10 = 20).\nMove to (0, 2), gaining another 10 coins (total coins = 20 + 10 = 30).\nMove to (1, 2), gaining the final 10 coins (total coins = 30 + 10 = 40).\n\n\n \nConstraints:\n\nm == coins.length\nn == coins[i].length\n1 <= m, n <= 500\n-1000 <= coins[i][j] <= 1000"
}