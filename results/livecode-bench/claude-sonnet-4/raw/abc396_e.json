{
  "task_id": "abc396_e",
  "llm_response": "def candidate_func(input_str):\n    lines = input_str.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    \n    constraints = []\n    for i in range(1, m + 1):\n        x, y, z = map(int, lines[i].split())\n        constraints.append((x - 1, y - 1, z))\n    \n    graph = [[] for _ in range(n)]\n    for x, y, z in constraints:\n        graph[x].append((y, z))\n        if x != y:\n            graph[y].append((x, z))\n    \n    result = [-1] * n\n    \n    for start in range(n):\n        if result[start] != -1:\n            continue\n        \n        component = []\n        stack = [start]\n        visited = set([start])\n        \n        while stack:\n            node = stack.pop()\n            component.append(node)\n            for neighbor, _ in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    stack.append(neighbor)\n        \n        if not component:\n            continue\n        \n        min_sum = float('inf')\n        best_assignment = None\n        \n        for start_val in range(32):\n            assignment = {}\n            assignment[component[0]] = start_val\n            queue = [component[0]]\n            valid = True\n            \n            while queue and valid:\n                current = queue.pop(0)\n                for neighbor, z in graph[current]:\n                    if neighbor in assignment:\n                        if assignment[current] ^ assignment[neighbor] != z:\n                            valid = False\n                            break\n                    else:\n                        assignment[neighbor] = assignment[current] ^ z\n                        queue.append(neighbor)\n            \n            if not valid:\n                continue\n            \n            for x, y, z in constraints:\n                if x in assignment and y in assignment:\n                    if assignment[x] ^ assignment[y] != z:\n                        valid = False\n                        break\n            \n            if valid:\n                current_sum = sum(assignment[node] for node in component)\n                if current_sum < min_sum:\n                    min_sum = current_sum\n                    best_assignment = assignment\n        \n        if best_assignment is None:\n            return \"-1\"\n        \n        for node in component:\n            result[node] = best_assignment[node]\n    \n    for node in range(n):\n        if result[node] == -1:\n            result[node] = 0\n    \n    for x, y, z in constraints:\n        if result[x] ^ result[y] != z:\n            return \"-1\"\n    \n    return ' '.join(map(str, result))",
  "model": "claude-sonnet-4",
  "task_description": "You are given integers N, M and three integer sequences of length M: X = (X_1, X_2, \\ldots, X_M), Y = (Y_1, Y_2, \\ldots, Y_M), and Z = (Z_1, Z_2, \\ldots, Z_M). It is guaranteed that all elements of X and Y are between 1 and N, inclusive.\nWe call a length-N sequence of non-negative integers A = (A_1, A_2, \\ldots, A_N) a good sequence if and only if it satisfies the following condition:\n\n- For every integer i with 1 \\le i \\le M, the XOR of A_{X_i} and A_{Y_i} is Z_i.\n\nDetermine whether a good sequence A=(A_1,A_2,\\ldots,A_N) exists, and if it exists, find one good sequence that minimizes the sum of its elements \\displaystyle \\sum_{i=1}^N A_i.\n\nNotes on XOR\n\nFor non-negative integers A and B, their XOR A \\oplus B is defined as follows:\n\n\n- In the binary representation of A \\oplus B, the digit in the place corresponding to 2^k \\,(k \\ge 0) is 1 if and only if exactly one of the digits in the same place of A and B is 1; otherwise, it is 0.\n\n\nFor example, 3 \\oplus 5 = 6 (in binary: 011 \\oplus 101 = 110).\n\nInput\n\nThe input is given from Standard Input in the following format:\nN M\nX_1 Y_1 Z_1\nX_2 Y_2 Z_2\n\\vdots\nX_M Y_M Z_M\n\nOutput\n\nIf no good sequence exists, print -1.\nIf a good sequence exists, print one good sequence that minimizes the sum of its elements, separated by spaces.\nIf there are multiple good sequences with the same minimum sum, printing any of them is accepted.\n\nConstraints\n\n\n- 1 \\le N \\le 2\\times 10^5\n- 0 \\le M \\le 10^5\n- 1 \\le X_i, Y_i \\le N\n- 0 \\le Z_i \\le 10^9\n- All input values are integers.\n\nSample Input 1\n\n3 2\n1 3 4\n1 2 3\n\nSample Output 1\n\n0 3 4\n\nA=(0,3,4) is a good sequence because A_1 \\oplus A_2 = 3 and A_1 \\oplus A_3 = 4.\nOther good sequences include A=(1,2,5) and A=(7,4,3), but A=(0,3,4) has the smallest sum among all good sequences.\n\nSample Input 2\n\n3 3\n1 3 4\n1 2 3\n2 3 5\n\nSample Output 2\n\n-1\n\nNo good sequence exists, so print -1.\n\nSample Input 3\n\n5 8\n4 2 4\n2 3 11\n3 4 15\n4 5 6\n3 2 11\n3 3 0\n3 1 9\n3 4 15\n\nSample Output 3\n\n0 2 9 6 0"
}