{
  "task_id": "3722",
  "llm_response": "def maxSum(nums, k, m):\n    n = len(nums)\n    if n < k * m:\n        return 0\n    \n    # Precompute prefix sums\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + nums[i]\n    \n    # Precompute max subarray sum ending at or before each position\n    def maxSubarraySum(length):\n        dp = [0] * (n + 1)\n        for i in range(length, n + 1):\n            dp[i] = max(dp[i - 1], prefix[i] - prefix[i - length])\n        return dp\n    \n    # dp[i][j] = maximum sum using i subarrays in first j elements\n    dp = [[-float('inf')] * (n + 1) for _ in range(k + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, k + 1):\n        maxPrev = [-float('inf')] * (n + 1)\n        maxPrev[m * i - m] = dp[i - 1][m * i - m]\n        \n        for j in range(m * i - m + 1, n + 1):\n            maxPrev[j] = max(maxPrev[j - 1], dp[i - 1][j - m])\n            \n        for j in range(m * i, n + 1):\n            # Try all possible last subarrays ending at position j-1 with length at least m\n            for length in range(m, min(j - m * (i - 1) + 1, 4)):\n                if j - length >= 0:\n                    dp[i][j] = max(dp[i][j], maxPrev[j - length] + prefix[j] - prefix[j - length])\n    \n    return max(dp[k][j] for j in range(k * m, n + 1))",
  "model": "qwen3-coder",
  "task_description": "You are given an integer array nums and two integers, k and m.\nReturn the maximum sum of k non-overlapping subarrays of nums, where each subarray has a length of at least m.\n \nExample 1:\n\nInput: nums = [1,2,-1,3,3,4], k = 2, m = 2\nOutput: 13\nExplanation:\nThe optimal choice is:\n\nSubarray nums[3..5] with sum 3 + 3 + 4 = 10 (length is 3 >= m).\nSubarray nums[0..1] with sum 1 + 2 = 3 (length is 2 >= m).\n\nThe total sum is 10 + 3 = 13.\n\nExample 2:\n\nInput: nums = [-10,3,-1,-2], k = 4, m = 1\nOutput: -10\nExplanation:\nThe optimal choice is choosing each element as a subarray. The output is (-10) + 3 + (-1) + (-2) = -10.\n\n \nConstraints:\n\n1 <= nums.length <= 2000\n-10^4 <= nums[i] <= 10^4\n1 <= k <= floor(nums.length / m)\n1 <= m <= 3"
}